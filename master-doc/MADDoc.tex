\documentclass[11pt,a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage[german]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{geometry}
\usepackage{nameref}
\usepackage{listings}
\geometry{a4paper, left=25mm, right=25mm, top=20mm, bottom=30mm}

\renewcommand{\headrulewidth}{1pt} % Trennunslinien für Kopf- und Fußzeilen
\renewcommand{\footrulewidth}{1pt}

\lhead{LAN-Monitoring} % Kopf- und Fußzeilen
\rhead{\chaptername \hspace{5mm} \thesection}
\lfoot{Du hasch deinen Namen vergessen}
\rfoot{\thepage}

\title{MAD-Network Monitoring\\
Diplomarbeit 2014/15}
\author{Porcic Alin, Ranalter Daniel, Singh Manpreet, Stojanovi\'{c} Marko\\
Betreuer: Dr. Michael Weiss\\
Höhere Technische Bundes Lehr- und Versuchsanstalt Anichstraße\\
Abteilung Höhere Elektronik und Technische Informatik\\
5bHEL}

\begin{document}
\maketitle
\newpage

%\setcounter{tocdepth}{6}
\tableofcontents
\newpage

\pagestyle{fancy}
\part{Abstract}
\chapter{Abstract}
\thispagestyle{fancy}

lorem ipsum

\part{Einleitung}
\thispagestyle{fancy}

lorem ipsum

\chapter{Aufgabenstellung}
lorem ipsum

\chapter{Aufteilung}
lorem ipsum 

\part{Theorie zu den einzelnen Gebieten der Arbeit}
lorem ipsum

\chapter{Informatik von Stojanovic Marko}
lorem ipsum

\section{Programmiersprachen}
lorem ipsum
\subsection{Was ist eine Programmiersprache?}
lorem ipsum
\subsection{C\#}
lorem ipsum
\subsubsection{Wie funktioniert C\#}
lorem ipsum
\subsubsection{Vor- und Nachteile}
lorem ipsum
%\subsection{Vergleich anderer möglicher Programmiersprachen}
%lorem ipsum
\section{Multithreading}
lorem ipsum
\subsection{Was ist ein Thread}
lorem ipsum
\subsection{Konzept von Multithreading}
lorem ipsum
\subsubsection{Wie funktioniert Multithreading}
lorem ipsum
\subsubsection{Hardware}
lorem ipsum
\subsubsection{Software}
lorem ipsum
\subsubsection{Arten von Multithreading}
lorem ipsum
\subsubsection{Vor- und Nachteile}

\lfoot{Ranalter Daniel}
\chapter{Netzwerkgrundlagen und Protokolle von Ranalter Daniel}
Diese Abhandlung wird die Netzwerkgrundlagen welche auf das Ethernet Protokoll (siehe Kapitel \ref{ssec:eth}  Seite \pageref{ssec:eth}) aufsetzen besprochen. Es gibt noch diverse andere, wie zum Beispiel Token Ring, auf welche hier im folgenden jedoch nicht näher eingegangen wird, da, abgesehen davon, dass Ethernet auch bei der praktischen Durchführung verwendet wurde, Ethernet das am häufigsten genutzte Layer 1 Protokoll darstellt. 
\section{Grundlagen}
In der Netzwerktechnik gibt es mehrere verschiedene grundlegende Konzepte auf welche hier eingegangen werden soll.
\subsection{Übersicht: Netzwerktypen}
Hier soll auf die wichtigsten Netzwerktypen kurz eingegangen werden. Es gibt einige mehr als jene die im Folgenden erwähnt werden, jedoch sollten sie die wichtigsten abdecken.
\subsubsection{LAN}
Das LAN, oder Local Area Network, bezeichnet ein Netzwerk welches von seinen Ausdehnungen her nicht mehr als 500 Metern überschreitet. Als LANs werden zum Beispiel Heimnetzwerke, Netzwerke in Schulen oder Arbeitsplätzen, besonders Büros, oder Bürogebäuden.
\subsubsection{W-LAN}
Das W-LAN erweitert das LAN um die im Namen (Wireless-LAN) steckende Freiheit von Kabeln. Dafür werden im Normalfall Router benötigt welche über die Möglichkeit verfügen im 2,4 oder 5 GHz Netz zu kommunizieren.
\subsubsection{WAN}
Das WAN, ausgeschrieben Wide Area Network, bezeichnet ein Netzwerk welches über ein sehr großes geographisches Gebiet verteilt ist. Es hat kein Limit an daran angeschlossenen Netzwerkgeräten. WANs werden beispielsweise von großen Firmen aber auch von Internetanbietern verwendet. Das Netzwerk mit welches ein Router den Enduser verbindet ist beispielsweise ein WAN des ISPs (Internet Service Providers wie UPC oder Telekom). 
\subsubsection{VLAN}\label{sssec:vlan}
VLANs (Virtual Local Area Network) sind im Grunde LANs welche logisch auf mehrere kleine Netzwerke aufgeteilt werden. Logisch deshalb, weil sie sich nicht physikalisch, also durch Router getrennt sind oder über eigene Kabel verfügen sondern nur dadurch getrennt sind, dass Switches Pakete von einem VLAN nicht in ein anderes lassen.\\
Es gibt mehrere unterschiedliche Arten von VLANs:\\
\begin{itemize}
\item Getaggtes VLAN\\
Bei dieser Art von VLAN weiß der Switch anhand ein paar Bytes im Ethernetframe selbst zu welchem VLAN es gehört, und damit auch wohin es überall kann.
\item Portbasierendes VLAN\\
Hierbei wird ein Switch selbst in mehrere logisch getrennte Sub-Switches aufgeteilt. Die Switches kommunizieren untereinander nicht.
\item Statisches VLAN\\
Beim statischen VLAN werden einzelne Ports an einem Switch dediziert einem VLAN zugeordnet. Nachteilig ist der große Aufwand ein solches VLAN zu verwalten.
\item Dynamisches VLAN\\
Beim dynamischen VLAN versucht der Switch anhand von Zusammenhängen im Datenverkehr zu entscheiden in welches VLAN ein Paket gehört. 
\end{itemize}
\subsection{Netzwerkdevices}
Um ein Netzwerk aufzubauen werden verschiedene Devices benötigt. Je nach Größe und Art des Netzwerkes kann man auch auf einzelne Komponenten verzichten. 
\subsubsection{Router}
Ein Router kommt in so gut wie jedem Netzwerk vor. Er operiert auf dem Layer 3 im OSI-Schichtenmodell, indem er Packete welche an seine seiner Interfaces reinkommen, anhand der IP-Adresse an einem anderen Interface wieder hinaus schickt. Dadurch verbindet er logisch getrennte Netze.\\

\begin{center}
\includegraphics[scale=0.5]{../docs/tarkes/pics/RouterNetwork.jpg}\label{fig:bspNetwork}
\end{center}

Das Wissen, welches Packet wohin muss, zieht er aus einer lokalen Routingtabelle. Diese Tabelle kann auf drei unterschiedliche Arten entstehen\\
\begin{itemize}
\item \textbf{Direkt angeschlossene Netze}\\
Netze welche direkt an einem seiner eigenen Interfaces hängen, erkennt er ohne weiteres zutun.\\
Auf dem Bild wären die Netze 192.168.11.0 192.168.12.0 und 192.168.22.0 dem Router1 also bekannt und er könnte Anfragen von Host121 an Host111 ohne Probleme weiterleiten.
\item \textbf{Statisches Routen}\\
Es ist dem Admin eines Netzwerkes möglich alle möglichen Routen von einem Netz zum anderen händisch am Router einzutragen.\\
Vorteilhaft daran ist die hohe Sicherheit und Kontrolle über das Netzwerk, nachteilig jedoch, dass es bei größeren Netzwerken sehr schnell unmöglich statisches routen anzuwenden da es sehr viel Arbeit darstellt jede mögliche Route händisch einzutragen ohne dabei einen Fehler zu machen.\\
Anhand des Bildes wäre es dem Administrator des Netzwerkes zum Beispiel möglich Router1 zu sagen, dass, wenn er zu Host212 kommen will, über das Netz 192.168.22.0 gehen muss. Was danach passiert, braucht Router1 nicht zu wissen, da sich nun Router2 um das Paket kümmern muss. Er erkennt, dass die Ziel IP-Adresse sich in einem direkt angeschlossenen Netz befindet, und schickt das Paket an dem entsprechenden Interface raus.
\item \textbf{Dynamisches Routen}\\
Beim dynamischen Routen lernt der Router anhand von eigenen Routing Protokollen wie er zu welchem Netz kommt. Es gibt einige verschiedene, welche alle verschiedene Prioritäten setzen. So versucht das Protokoll OSPF (Open Shortest Path First) immer so wenig Hops, also Netzwerkwechsel/Router, wie möglich passieren zu müssen. RIP (Routing Information Protocol) und dessen Nachfolger RIP2 werden zwar noch verwendet, aber als veraltet angesehen.
\end{itemize}

Des weiteren gibt es verschiedenste Arten von Routern. Ihre Grundfunktionalitäten sind zwar immer die gleichen, jedoch würde das kleine Kästchen das zuhause steht, nie ausreichen um den Traffic der Backboneleitungen, also der großen Glasfaserleitungen welche die Kontinente verbinden, zu routen. Dafür würde diesem Router einfach die Leistung fehlen.\\
Deshalb gibt es verschiedene Arten von Routern. Ein paar wichtige sind:\\
\begin{itemize}
\item Backbone-Router\\
Hochgradig auf Datendurchsatz optimiert, werden sie, wie der Name schon sagt, für das Routen an der Backbone verwendet.
\item Edge-Router, Border-Router\\
Wird von ISPs verwendet um die Netzwerke ihrer Clienten zu verbinden. Sie verwenden normalerweise das Routing Protokoll BGP (Border Gateway Protocol) welches für diese Aufgabe ausgelegt ist.
\item WLAN-Router\\
Im Grunde ganz normale Router, welche jedoch zusätzlich die Möglichkeit besitzen nicht nur kabelgebunden zu kommunizieren sondern auf über das Funkband. In Österreich sind die Bänder 2,4 GHz und 5 GHz in Verwendung.
\item Customer-Edge-Router\\
Werden meistens von den ISPs den Kunden zur Verfügung gestellt. Die meisten unterstützen heutzutage auch WLAN.
\end{itemize}
\subsubsection{Switch}
Ein Switch ermöglicht die Kommunikation zwischen mehreren Hosts. Einfache Switches agieren hauptsächlich auf dem Layer2: Sie schreiben sich auf an welchem Port welche MAC-Adresse hängt und wissen dann durch Source und Destination MAC-Adresse, an welchen Interface das Paket wieder raus muss.\\

Im Gegensatz zu ihren Vorgängern, den Hubs, sind sie damit in der Lage, Pakete zielgerichtet weiter zu leiten. Hubs lenken einkommenden traffic nicht, sie schicken die Pakete immer an alle Interfaces. Switches legen dazu eine lokale Switching Tabelle an in welcher sie stehen haben, an welchem Interface welche MAC-Adresse liegt.\\
Darin findet sich jedoch auch die größte Sicherheitslücke, wie später in Kapitel \ref{sssec:security} auf Seite \pageref{sssec:security} noch besprochen wird.\\


Switches trennen also auch keine Netze, sondern sorgen für Kommunikation innerhalb eines Netzes. So sieht man zum Beispiel im vorhergehenden Bild, dass die Switches, abgebildet als viereckige Kästchen, drei PCs zu einem Netzwerk zusammenfassen und mit dem Router verbinden.\\


Auch hier gibt es wieder verschiedene Ausführungen. Die wichtigsten sind die Standart Switches welche auf Layer 2 agieren.\\
Als nächste große Gruppe gibt es die sogenannten Layer 3 Swichtes. Diese, wie der Name bereits andeutet, verfügen über Funktionalitäten auf dem 3. Layer der OSI-Schicht. So sind sie in der Lage zu routen, was vorallem bei VLANs benötigt wird, oder auch die Priorisierung von bestimmten Paketen um Quality of Service zu gewährleisten.\\
Es gibt auch noch Switches welche höheren Layers zugeordnet werden, diese sind jedoch nicht einheitlich, sondern definiert jeder Hersteller das etwas anders.
\subsubsection{Firewall}
Die Firewall ist eine Sonderform des Routers.\\
Eigentlich ist die Firewall ansich nur eine Software welche nach zugrunde liegenden Bestimmungen entscheidet welche Pakete durch dürfen und welche nicht. Jedoch wird dies in großen Firmen häufig von einem dafür spezialisieren Router erledigt, welcher dann als Firewall bezeichnet wird.\\
Diese Router haben dann meistens nur 2 Ports, da ihre einzige Aufgabe ja darin besteht Pakete zu blockieren oder durchzulassen. Dafür sind sie sehr stark auf ihren Datendurchsatz optimiert, da sie so gut wie immer den Flaschenhals eines Netzes darstellen.\\
Es gibt auch hier unterschiedliche Arten von Firewalls:\\
\begin{itemize}
\item \textbf{Packet Filters}\\
Packet Filters sind die primitivste Art von Firewalls. Sie entscheiden anhand der Source- und Destination IP, Source- und Destination Port sowie UDP/TCP parameter ob ein Paket als Vertrauenswürdig eingestuft wird oder nicht.
\item \textbf{Stateful Inspection}\\
Dies stellt eine Erweiterung zu dem Packet Filter dar. Die Firewall speichert nun auch den State, also den Zustand, eines Paketes oder einer Kommunikation. So kann man der Firewall zum Beispiel sagen, dass Pakete welcher zu einer bestehenden Kommunikation gehören durchgelassen werden dürfen. 
\item \textbf{Application Level Firewall}
Der Vorteil dieser Art an Firewall ist, dass sie in der Lage ist bestimmte Protokolle und Anwendungen zu \glqq verstehen\grqq . Das bietet den Vorteil, dass sie erkennen kann ob ein ungewolltes Protokoll über einen offenen Port kommt.
\item \textbf{Deep Inspection}\\
Während Stateful Inspection sich nur den Header des Paketes ansieht, greift die Deep Inspection in die Payload, also die Nutzdaten, ein um genaue Informationen über den Inhalt zu erlangen. Dies geht sogar soweit, dass die Firewalls Verschlüsselungen versuchen aufzubrechen.\\
Vorteilhaft daran ist die relativ hohe Sicherheit, da auch Pakete welche auf einem scheinbar harmlosen Port kommen und auch das passende Protokoll haben, manipuliert sein können, Nachteilig jedoch, dass die Firewall damit in der Lage ist, absolut alles an Informationen über den Netzwerkverkehr aufsammeln zu können was sie will. Die Anonymität ist damit nicht länger gewährleistet.
\end{itemize}
\subsection{Der Host}
Mit dem Term \glqq Host\grqq , wird, in dem Zusammenhang der Netzwerktechnik, ein Gerät beschrieben, welches über das Netzwerk mit anderen Hosts verbunden ist und theoretisch in der Lage ist an der Kommunikation teilzunehmen. Damit ein Host zur Kommunikation in der Lage ist, benötigt er mehrere Dinge.\\
Zu diesen gehört Hardware technisch gesehen, mindestens eine Netzwerkkarte mit einer Art von Möglichkeit sich in das Netz einzuklinken. Diese Möglichkeit kann aus einem Ethernet Anschluss oder einer Antenne, welche in der Lage ist, das 2,4 GHz Band und/oder das 5GHz Band zu empfangen und in diesem Band zu senden.\\
Auf der Softwareseite benötigt ein Host im Grunde drei Dinge welche ihn dazu ermöglichen eine Konversation mit einem anderen Host, über das Internet, zu führen. Es gibt natürlich auch andere Arten von Kommunikation in Netzwerken, jedoch ist das TCP/IP (siehe \ref{sssec:tcpip} auf Seite \pageref{sssec:tcpip}) Modell das am häufigsten vorkommende. 

\subsubsection{MAC-Adressen}\label{sssec:macaddr}
MAC-Adresse steht für Media Access Controll Adresse und ist dem Layer 2 zugewiesen. Die MAC-Adresse heißt in Apple Systemen auch \glqq Ethernet-ID\grqq , \glqq Airport-ID\grqq oder \glqq Wi-Fi-Adresse\grqq . Sie sollte theoretisch jedes Netzwerkinterface eindeutig kennzeichnen, jedoch ist es mit moderner Software möglich die MAC-Adresse zu ändern.\\
Da die MAC-Adresse nicht mehr, wie ursprünglich gedacht, in die Netzwerkkarte \glqq eingebrannt\grqq ist, kann sie von Hackern eingesetzt werden um Schaden anzurichten (siehe Kapitel \ref{ssec:mspoof} und \ref{ssec:mflood} auf Seiten \pageref{ssec:mspoof} und \pageref{ssec:mflood})\\

Die MAC-Adresse besteht aus sechs Byte (oder 48 bit) und wird normalerweise in hexadezimaler Notation dargestellt. Oft wird sie zur besseren Lesbarkeit byteweise durch einen Doppelpunkt oder einen Bindestrich getrennt, zum Beispiel a3:99:2f:9b:cc:00 oder eben a3-99-2f-9b-cc-00.\\

Die ersten zwei Bits des ersten Bytes bestimmen außerdem die Art der MAC-Adresse. Das erste Bit des ersten Bytes signalisiert ob es eine Unicast- (0, Adresse die für ein Device steht), eine Multicast- (1, Adresse die für mehrere Devices steht) oder sogar Broadcast Adresse(1, Adresse die für alle Devices in einer Broadcast Domain steht) ist.\\
Das zweite Bit steht dafür ob es eine global administrierte(0) oder eine lokal administrierte Adresse(1) handelt, was aussagt ob die Adresse weltweit eindeutig ist, wie es normalerweise bei gekauften Netzwerkkarten der Fall sein sollte, oder ob der Administrator die MAC-Adresse selbst vergibt um Eindeutigkeit zu wahren.

Ohne Kenntnis über die MAC-Adresse, wäre es nicht möglich in einem Netzwerk zu kommunizieren, da das Ethernetframe die Sender und die Empfänger MAC-Adresse verlangt.\\
Für den Fall, dass sich der Zielhost nicht im gleichen Netz befindet, sich also in einem durch einen Router getrennten, anderen Netz befindet, würde für die Ziel MAC-Adresse, jene des Routers angegeben. Sollte sich die Adresse des Ziels nicht im Cache des Rechners befinden, wird das Protokoll ARP verwendet (siehe Kapitel\ref{ssec:arp} Seite \pageref{ssec:arp}). 
\subsubsection{IP-Adressen}\label{sssec:ipaddr}
Im folgenden wird nur auf IP version 4 eingegangen. Informationen zu IP version 6 können in Kapitel \ref{ssec:ip} auf Seite \pageref{ssec:ip} gefunden werden.\\

Die zweite Adresse die ein Host benötigt um mit anderen zu kommunizieren oder Daten auszutauschen ist die IP-Adresse, was für Internet Protokoll Adresse steht. Diese wird dem Layer 3 des OSI-Schichtenmodells zugewiesen. Es gibt auch noch einige andere Protokolle auf Layer 3, jedoch setzen Netzwerke, wie sie im Projekt bearbeitet wurden, sowie das Internet hauptsächlich auf IP auf.\\

Die IP-Adresse besteht aus 32 bit oder 4 byte, welche in der Regel in vier Oktete aufgeteilt und mit einem Punkt getrennt wird. Man hat also vier, durch einen Punkt getrennte Zahlen, welche sich alle im Bereich zwischen inklusive 0 und 255 befinden.\\

Wie bereits zuvor beschrieben wird die MAC-Adresse verwendet um im gleichen Netz adressieren zu können und für den Fall, dass das Ziel sich in einem logisch getrennten Netz befindet, wird die MAC-Adresse des Routers verwendet. Damit man trotzdem weiß zu welchem Host das Paket muss, verwendet man die IP-Adresse welches Netze übergreift.\\

Eine IP-Adresse wird normal ein zwei Teile gespalten. Es gibt den Netzteil und den Hostteil einer IP-Adresse. Der Netzteil einer Adresse kennzeichnet, wie der Name bereits sagt, in welchen Netz sich ein Host befindet. Der Hostteil hingegen kennzeichnet einen einzelnen Host in diesem Netz.\\
Um zu erkennen welcher Teil einer IP-Adresse der Netzteil und welcher der Hostteil ist, verwendet man sogenannte Subnetzmasken. Die Subnetzmaske besteht aus einer dezimalen Zahl zwischen 1 und (theoretisch) 32 und gibt an wieviele bits der IP-Addresse zum Netzteil gehören. So wäre zum Beispiel bei der Adresse \textit{192.168.1.1/24} ein Anteil von 24 bit dem Netzteil zugehörig. 24 bit entsprechen 3 byte, also die ersten 3 dezimalen Zahlen 192.168.1 sind das Netz und .1 ist der Host.
\subsubsection{Ports}
Werden auf der Transportschicht, also Layer 4, die Protokolle TCP oder UDP verwendet, werden jedem Host, zusätzlich zu dem zuvorgenannten Werten, auch noch sogenannte Ports zugewiesen. Es gibt immer einen Source-Port und einen Destination-Port.\\
Ports bewegen sich in einem Raum von 0 bis 65535. Dieser Bereich wird aufgeteilt in drei kleinere Bereiche.\\
Ersterer sind die sogenannten well-known Ports, also jene welche von allen gekannt und anerkannt werden. Er erstreckt sich von den Nummern 0 bis 1023. Ports in diesem Bereich sind von der IETF (Internet Engineering Task Force) mit bestimmten, wichtigen Anwendungen verknüpft worden. So ist das File Transport Protocol ftp auf Port 21 zu finden.\\
Zweiter Bereich sind die Registered Ports. Sie stellen eine Art Übergangsbereich dar, denn sind hier zwar registrierte Anwendungen zu finden, kann man auch ohne Einverständnis der IETF Ports in diesem Bereich belegen. Der Bereich geht von 1024 bis 49151.\\
Der dritte Bereich, Dynamic Ports, sind alle restlichen über 49151 und stehen dem Betriebssystem frei zur Verfügung um sie den Clientprogrammen zu geben.\\

Ohne Ports wäre es nicht möglich mehrere Netzwerkanwendungen gleichzeitig zu betreiben, da der Client nicht mehr in der Lage wäre, die eingehenden Netzwerk Pakete den entsprechenden Anwendungen zuzuordnen. So ist er in der Lage, mehrere Verbindungen zu verschiedenen Server offen zu halten, da er sich jedesmal einen neuen Source-Port aufmacht. Ansonsten wäre zum Beispiel das offen haben von Facebook, Youtube und Reddit gleichzeitig garnicht möglich, geschweige denn mehrere Downloads von Servern.\\

Wie erwähnt gibt es, wie bei den zuvor genannten Werten, auch hier Source und Destination. Während der Destination Port bei einem Client meistens anhand der Art von Anwendung vorbestimmt ist, ist der Source Port frei zu wählen solang er über 1024 liegt. Meistens wird jedoch ein Port über 30000 verwendet. 
\subsection{Schichtenmodel}
Das Schichtenmodel ist ein im Bereich der Softwarearchitektur häufig verwendetes Strukturierungsprinzip, indem Schichten immer auf die Resourcen der unteren Schicht zugreifen können, ohne sich Gedanken um deren Format oder ähnliches machen zu müssen, während sie selbst oberen Schichten fixierte Objekte zur Verfüfung stellen. In der Netzwerktechnik gibt es zwei Schichtenmodelle.
\subsubsection{OSI}
Das OSI-Layer Modell wurde 1984 von der International Organization for Standardization (ISO) als Standardreferenzmodell für Telekommunikation in Netzwerken festgelegt.\\
Das OSI-Layer Modell teilt die gesamte Kommunikation in einem Netzwerk in 7 Schichten auf, welche nach oben hin immer weiter abstrahieren, wobei eine Ebene immer die Ebene über sich bedient und von der unteren Ebene bedient wird.\\
\paragraph{Layer 1 - Physical Layer}
Die erste Ebene ist auch die am wenigsten abstrahierte Ebene.\\
Wie der Name schon andeutet geht es beim Physical Layer um die physikalischen Eigenschaften der Verbindung. Dazu gehören Pin Layout, Leitungsimpedanzen oder welche Art der Verbindung (Koaxial Kabel, Lichtwellenleiter, ..) verwendet wird. Auch die Art der verwendeten Modulation oder das umwandeln von Daten in Spannungen wird auf diesem Layer festgelegt.\\ Hier ist noch nicht festgelegt wie die einzelnen Bits von einem Host zum anderen finden, sondern eher wie ein Bit auf einer Leitung überhaupt dargestellt wird und wie es transportiert wird.\\

Beispielhafte Protokolle auf dieser Ebene sind:
\begin{itemize}
\item Ethernet mit seinen Varianten
\item DSL 
\item Varianten vom 802.11 Wireless standart
\item Bluetooth
\item CAN bus
\item ...
\end{itemize}
\paragraph{Layer 2 - Data Link Layer}
Der zweite Layer im OSI-Modell ist der Data Link Layer.\\
Er ermöglicht die Kommunikation zwischen zwei benachbarten Netzwerkgeräten in einem Netzwerk. Weiters kann er Mittel zur Verfügung stellen, Fehler welche auf dem Physical Layer auftreten können, zu beheben. So tritt hier auch die erste Adresse auf, die MAC-Adresse.\\

Beispielhafte Protokolle auf dieser Ebene sind:
\begin{itemize}
\item Ethernet
\item Token Ring
\item Spanning Tree 
\item Point-to-Point PPP
\item Multiprotocol Label Switching MLPS
\item ...
\end{itemize}
\paragraph{Layer 3 - Network Layer}
Die nächst höhere Ebene ist der Network Layer.\\
Während der Data Link Layer für die Kommunikation von zwei benachbarten Netzwerkgeräten zuständig ist, ist der Network Layer für die End-to-End Verbindung zuständig, welche auch über mehrere Netzwerkgeräte laufen kann, also auch über mehrere Netze hinweg. Damit müssen die Protokolle auf diesem Layer eine Möglichkeit zur Adressierung bereitstellen welche auch auf große Entfernungen, im logischen Sinne, eindeutig sind. Eine Möglichkeit sind die bereits besprochenen IP-Adressen.\\

Beispielhafte Protokolle auf dieser Ebene sind:
\begin{itemize}
\item Internet Protocol IP
\item Routing Information Protocol ARP
\item Internet Control Message Protocol ICMP
\item Internet Protocol Security IPsec
\item ...
\end{itemize}

\paragraph{Layer 4 - Transport Layer}
Die Aufgabe des vierten Layers ist die Aufteilung eines Datenstromes in Segmente. Damit ermöglicht er es Daten die größer sind als nur ein Paket zu verschicken. Des weiteren ist diese Schicht für das Aufrechterhalten des Quality of Service wichtig. Besonders wichtig sind die Protokolle TCP und UDP auf dieser Schicht. Auch werden auf dieser Ebene die Ports in die Adressen mithineingenommen.\\

Beispielhafte Protokolle auf dieser Ebene sind:
\begin{itemize}
\item Transmission Control Protocol TCP
\item User Datagramm Protocol UDP
\item AppleTalk Trasaction Protocol ATP
\item Fibre Channel Protocol FCP
\item Stream Control Transmission Protocol SCTP
\item ...
\end{itemize}

\paragraph{Layer 5 - Session Layer}
Die fünfte Schicht des OSI-Schichtenmodelles ist für das Aufrechterhalten der einzelnen Sessions, also die Gespräche zwischen zwei Endgeräten miteinander zuständig. Er verwendet die unter ihm liegenden Ebenen um seine Gespräche auf die vorhandene Netzstruktur aufzubauen und hält diese dann am Leben.\\

Beispielhafte Protokolle auf dieser Ebene sind:
\begin{itemize}
\item Net-BIOS
\item AppleTalk Session Protocol ASP
\item Point-to-Point Tunneling Protocol PPTP
\item Password Authentification Protocol PAP
\item ...
\end{itemize}

\paragraph{Layer 6 - Presentation Layer}
Die Darstellungsschicht wirkt als reiner Übersetzer. Sie nimmt die Daten der Anwendungsschicht und bereitet sie so auf, dass sie für untere Schichten brauchbar werden. Falls es notwendig ist, übersetzt sie auch Dateiformate in andere Codierungen. Außerdem ist diese Ebene für die Serialisierung von komplexen Datenstrukturen in einfache \glqq flache\grqq Byteketten, wie sie zum Beispiel in XML verwendet werden, zuständig.\\

Beispielhafte Protokolle auf dieser Ebene sind:
\begin{itemize}
\item telnet
\item Lightweight Presentation Protocol LPP
\item Independent Computing Architecture ICA (verwendet in Citrix)
\item ...
\end{itemize}

\paragraph{Layer 7 - Application Layer}
Der Application Layer, oder Anwendungsschicht, stellt das Interface dar welches schlussendlich unter der, von dem User verwendeten, Applikation liegt. Sie ist die am meisten abstrakte Schicht und damit auch dem User am nächsten. Protokolle in dieser Schicht kümmern sich ausschließlich um die Aufgabe welches jedes einzelne ganz speziell hat.\\

Beispielhafte Protokolle auf dieser Ebene sind:
\begin{itemize}
\item Hypertext Transfer Protocol HTTP
\item Simple Mail Transfer Protocol SMTP
\item Simple Network Management Protocol SNMP
\item Network Time Protocol NTP
\item Lightweight Directory Access Protocol LDAP
\item ...
\end{itemize}
\subsubsection{TCP/IP}\label{sssec:tcpip}
Das TCP/IP Schichtenmodell heißt eigentlich die \glqq Internetprotokollfamilie\grqq oder \glqq Internet Protocol Suite\grqq . Seinen umgangssprachlichen Namen hat es von den beiden Protokollen TCP und IP, die beiden wichtigsten Protokolle des Internets, welche auch als erste in die Sammlung an Protokollen aufgenommen wurden. Doch eigentlich umfasst die Internet Protocol Suite über 500 verschiedene Protokolle.\\
Die Internet Protocol Suite wurde von dem amerikanischen Department of Defense (DOD) entwickelt.\\


Die Internet Protocol Suite bestimmt das TCP/IP-Referenzmodel, welches ebenso wie das OSI-Schichtenmodel auf mehrere Schichten aufbaut.\\
Während das OSI-Layer Modell 7 Schichten bestimmt, verwendet das TCP/IP-Referenzmodell nur 4 Schichten. Diese wären:\\

\paragraph{Layer 1 - Link Layer}
Der Link Layer im Referenzmodell vereinigt die OSI-Schichten 1 und 2 in sich. Er ist also sowohl für die physikalischen Eigenschaften des Netzes zuständig als auch für die grundlegende Übermittlung von Daten.

\paragraph{Layer 2 - Internet Layer}
Die zweite Schicht entspricht dem Network-Layer im OSI-Schichtenmodell. Bis auf die Namensänderung gibt es jedoch keinen Unterschied, wichtigstes Protokoll ist auch hier das namensgebende Internet Protokoll.

\paragraph{Layer 3 - Transport Layer}
Der Transport Layer im TCP/IP Modell entspricht seinem gleichnamigen Bruder im OSI-Modell. 

\paragraph{Layer 4 - Application Layer}
Alle Schichten die danach folgen würden, werden im TCP/IP-Modell zusammengefasst zum Application Layer.\\

Nun ist relativ ersichtlich, dass sich das TCP/IP-Referenzmodell sich sehr stark auf den Internet und den Transport Layer konzentriert, während die Layer darunter und darüber beinahe vernachlässigt werden. Dies ist auch der größte Kritikpunkt an diesem Modell.\\
In der Praxis wird das TCP/IP-Modell verwendet solange die Abstrahierung nicht zu weit geht, sollte man jedoch genauer arbeiten wird meistens auf das genormte und genauere OSI-Schichtenmodell zurückgegriffen.
\subsection{Client-Server Verhältnis}
Das Client-Server Modell ist das bekannteste und am öftesten verwendete Muster für Aufgabenverteilung in einem Netzwerk.\\ 
Bei diesem Modell gibt es denjenigen der die Dienste anbietet, den Server, und denjenigen der die Dienste nutzt, den Client.\\

Mit dem Begriff \glqq Server\grqq können sowohl die Hardware als auch die Software gemeint sein.\\
Hardware-Server unterscheiden sich meistens nicht sehr von normalen Desktop-PCs, bis auf ihre Leistung welche meistens auf ihre Aufgabe abgestimmt ist. Oft wird weniger Rechenleistung benötigt als RAM ein anderes mal umgekehrt. Manchmal wird auch viel Speicherplatz gebraucht.\\
Auch die Abmessungen variieren deutlich. Bei kleinen Servern, wie sie manche auch zuhause stehen haben, ist es oft nur ein normaler Tower, nur halt ohne Bildschirm, während große Firmen oder Organisationen häufig sogenannte \glqq Racks\grqq vollgestopft mit Blade-Servern stehen haben.\\
Ein Rack ist ein Gestell in welches man Blade-Server einfach hineinschieben kann. Blade-Server (Blade deutsch: Klinge) haben ihren Namen von ihrem sehr schlanken Design.\\

\begin{center}
\includegraphics[scale=0.8]{../docs/tarkes/pics/ServerRack.jpg}\\
Ein Rack mit mehreren Blade-Servern 
\end{center}

Als Software-Server werden Programme bezeichnet welche Dienste anbieten. Zu solchen zählt zum Beispiel der Webserver Apache, der FTP-Server Filezilla oder auch bind, die Referenzimplementierung eines DNS-Servers.\\
Software-Server werden häufig als Dienste oder Deamons bezeichnet. Sie laufen im Hintergrund, haben häufig, vorallem auf unixoiden Betriebssystemen, keine grafische Oberfläche sondern lediglich mehr oder weniger viele Konfigurationsdateien, und müssen so programmiert sein, dass sie großen Mengen an Anfragen begegnen können ohne, dass sie der Maschine auf welcher sie laufen ihre gesamten Resourcen wegfressen.\\

Clients sind ebenso vielfältig. Zu den Clients zählt jeder, der einen Dienst eines Servers in Anspruch nimmt. 
\subsection{Beispiel für Kommunikationsablauf}
Im folgenden soll das Abrufen einer Seite von einem Web-Server, welcher in einem anderen Netzwerk steht, aus netzwerktechnischer Sicht, Schritt für Schritt besprochen werden.\\
\begin{enumerate}
\item Schritt:\\
Der User öffnet den Browser seiner Wahl und tippt die URL (Unified Resource Locater) in die Adressenleiste. Der Computer kann mit diesem Namen ansich nichts anfangen, also versucht er zuallererst in der Datei \glqq hosts\grqq , welche unter Windows im Dateipfad
\begin{lstlisting} 
C:\Windows\System32\drivers\etc\ 
\end{lstlisting} zu finden ist, und unter Unixoiden Betriebssystemen meistens unter 
\begin{lstlisting} 
\etc\ 
\end{lstlisting} liegt, nach einer zugewiesenen IP-Adresse für diesen Namen zu suchen.\\
Findet er eine IP-Adresse fährt er mit Schritt 2 fort, ansonsten prüft der Rechner als nächstes seinen DNS-Cache nach einem entsprechenden Eintrag. Wurde die Seite bereits vor nicht allzu langer Zeit aufgerufen, besteht eine gute Chance, das der entsprechende DNS Eintrag noch im Cache zu finden ist.\\
Auch hier fährt er bei Erfolg mit Schritt 2 fort. Sollte jedoch weder im Cache noch in der hosts Datei ein Eintrag zu dieser Seite stehen, muss der Rechner eine DNS-Anfrage durchführen.\\
\begin{enumerate}
\item Um eine DNS anfrage zu machen benötigt der Rechner zuerst die IP-Adresse des DNS-Servers. Die hat er entweder statisch eingetragen bekommen oder zusammen mit seiner IP-Adresse, dem Standart Gateway und anderem Zeug beim DHCP bekommen.
\item Die IP-Adresse welche er nun hat, vergleicht er mit seinem Netz indem er die Subnetzadresse mit der IP-Adresse des Zieles und seiner eigenen bitweise UND verknüpft. Nun gibt es zwei Möglichkeiten: 
\begin{itemize}
\item Der DNS-Server befindet sich in seinem Netz
\item Der DNS-Server befindet sich nicht in seinem Netz
\end{itemize}
\item Für den Fall, dass sie sich im gleichen Netz befinden:\\
Der PC braucht nun die MAC-Adresse zu der IP-Adresse. Zuerst sieht er wieder nach, ob er sie gecached hat. Sollte er sie nicht im Cache liegen haben, schickt er einen ARP-Request raus. Dieses Protokoll frägt wer denn eine bestimmte IP-Adresse hat, und ob derjenige ihm seine MAC-Adresse verraten würde. 
\item Für den Fall, dass sie sich nicht im gleichen Netz befinden:\\
Wenn der PC erkennt, dass sich das Ziel außerhalb seines Netzes befindet, also schickt er es an den Default Gateway.\\
Der Default Gateway ist jene IP-Adresse an die alles von allen geschickt wird, was sich nicht in ihrem Netz befindet, also muss auch jedes Netz einen Default Gateway haben. Die Gateway-Adresse gehört meistens zu einem Router, welcher dann anhand der IP-Adresse, das Paket weiterleitet bis es schlussendlich sein Ziel erreicht.\\
\item Nun verfügt der PC um alle Parameter die er braucht um das DNS-Paket zusammenzubauen. TCP/IP Layer 1 hat die MAC-Adresse, TCP/IP Layer 2 hat die IP-Adresse, der Rechner weiß, dass DNS normalerweise auf UDP aufsetzt und kann deshalb Layer 3 den UDP Port 53 bestimmen und das DNS Paket selbst auf der Anwendungsschicht, dem TCP/IP Layer 4. Er öffnen noch einen Port über den 49151 als Source-Port, trägt diesen in das Paket auf dem Layer 3 ein, schickt das Paket ab und muss nur noch auf die Antwort, mit der IP-Adresse der Seite warten.
\end{enumerate}
\item Schritt:\\
Nun, da er über die IP-Adresse des Webservers verfügt, durchläuft der Rechner alle Schritte, welche er bei der DNS-Anfrage durchlaufen hat, nocheinmal, nur diesesmal mit der IP-Adresse des Web-Servers, anstatt der des DNS-Servers.
\item Schritt:\\
Wenn er wieder die Informationen die er benötigt hat für diese Anfrage gesammelt hat, baut er wieder das HTTP-Request Paket zusammen, mit MAC- und IP-Adresse, diesesmal TCP Port 80, und der Seite im HTTP Teil des Paketes. Er wartet auf die Antwort Pakete, baut die Seite im Browser auf und der User bekommt was er will.
\end{enumerate}
\section{Protokolle}
Es gibt unzählige verschiedene Protokolle, hier soll nur auf ein paar wenige wichtige eingegangen werden, welche auch Verwendung im praktischen Teil der Diplomarbeit gefunden haben.
\subsection{Ethernet}\label{ssec:eth}
Ethernet ist ein wowohl ein Layer1 als auch ein Layer2 Protokoll im OSI-Modell und damit für die unterste Schicht und den grundlegenden Kommunikationsmöglichkeiten zuständig.\\

Ethernet wurde ursprünglich für Lokale Netzwerke erdacht, weshalb es häufig als LAN-Technologie bezeichnet wird. Da das Protokoll vor über 30 Jahren begann zu existieren, wäre es natürlich nicht mehr ausreichend für heutige Anwendungen, doch es ist mit der Entwicklung des Internets mitgewachsen.\\
Während es anfangs nur für einzelne Häuser gedacht war, können inzwischen mittels Lichtwellenleitern Entfernungen von über 10 Kilometern überbrückt werden.\\

Auch die Datenrate wuchs zusammen mit dem Rest. Anfangs lief es nur über Twisted Pair oder Koaxial Kabel, während inzwischen der Lichtwellenleiter bis zum Endbenutzer in den Haushalt gefunden hat.\\

Da Ethernet über die Zeit so gewachsen ist, gibt es auch sehr viele verschiedene Standards. Hier soll nur auf ein paar der neuesten Eingegangen werden, da dies den Rahmen ansonsten sprengen würde.\\
\begin{itemize}
\item 10Gbit/s:
\begin{itemize}
\item Lichtwellenleiter Multimode:\\
10GBASE-SR\\
Zur Überbrückung kurzer Strecken mit langwelligem Licht, Reichweite je nach Leitungstyp zwischen 26 und 300 Metern.
\item Lichtwellenleiter Singlemode:\\
10GBASE-LW4\\
Zur Überbrückung langer Strecken mit Distanzen bis zu 10 Kilometern.
\end{itemize}
\item 40Gbit/s:
\begin{itemize}
\item 40GBASE-CR4\\
4 x Kufper Twinax Kabel für Reichweiten von mindestens 4 Metern.
\item 40GBASE-LR4\\
Vier Farben Multimoden Lichtwellenleiter für Reichweiten von mindestens 10 Kilometern.
\end{itemize}
\item 100Gbit/s:
\begin{itemize}
\item 100GBASE-CR10\\
10 x Kufper Twinax Kabel für Reichweiten von mindestens 7 Metern.
\item 100GBASE-ER4\\
4 Farben Singlemoden Lichtwellenleiter für Reichweiten von über 40 Kilometern.
\end{itemize}
\end{itemize}
Seit 2013 wird jedoch von einer Arbeitsgruppe der IEEE an einem Standart für 1TBit/s gearbeitet, der circa 2017 fertiggestellt werden soll.\\

Da die Wurzeln dieses Protokolls, in einem gemeinsam genutzten Koaxial Kupfer Kabel liegen, war eines der Probleme sogenannte Kollisionen, also wenn zwei Rechner zur gleichen Zeit sprechen wollten.\\
Diesem Problem wurde mit dem CSMA/CD Algorithmus zu Leibe gerückt. CSMA/CD, was für Carrier Sense Multiple Access/Collision Detection steht, ist eine Weiterentwicklung des, in den 1960 Jahren, auf Hawaii verwendeten ALOHAnet Protokolls.\\
Dabei warten Teilnehmer des Netzwerkes immer, bis die Leitung nicht mehr belegt ist, bevor sie anfangen Daten zu übermitteln. Sollten jedoch zwei Rechner gleichzeitig beginnen zu reden, stoppen beide und warten eine zufällige Zeitdauer bis sie es erneut versuchen.\\
Obwohl nun seit einigen Jahren sowohl Full-Duplex Modus und Switches verwendet werden, welche Kollisionen verhindern indem sie End-to-End Verbindungen erzeugen, befindet sich der Algorithmus bis zu den 10Gbit/s Standards immer noch zu den verwendeten Algorithmen.\\
Bei den höheren Netzen, wo CSMA/CD nicht mehr verwendet wird, wird ein extra Flowcontrol System verwendet. Bei CSMA/CD war das nicht notwendig, da eine Kollision sowieso eine Pause im Datenfluss hervorgerufen hat. Nun, ohne diesen Algorithmus, muss es jedoch trotzdem eine Möglichkeit geben, anderen zu vermitteln, dass eine Sendepause vonnöten ist. Dies wird bei Ethernet über 10Gbit/s mit einem bestimmten PAUSE Paket geregelt, in welchem die gewünschte Wartezeit notiert ist.\\

Ebenfalls in den Wurzeln des Protokolls verankert, ist das Broadcast Problem.\\
Das Ethernet Protokoll hat sich nie um zielgerichtete Kommunikation gekümmert, weshalb es ohne weiteres alles an alle schickt. Das kann zu einem Problem werden, wenn ein Mensch mit böswilligen Absichten mitschreiben will was im Netzwerk so passiert, denn das kann er dann tun.\\
Als noch Hubs verwendet wurden, was da Problem viel drastischer, denn ein Hub repliziert die Pakete die er empfängt und schickt diese an alle Interfaces raus.\\
Switches dahingegen schicken, wie bereits besprochen, Pakete nur an jenen Interfaces raus, wo auch das Ziel ist. Sie verhindern damit das sogenannte \glqq sniffen\grqq im Netzwerk.\\
Eine andere Option ist Verschlüsselung auf welchen im Kapitel \ref{chap:krypto} auf Seite \pageref{chap:krypto} noch näher eingegangen wird.\\

\begin{center}
\includegraphics[scale=0.35]{../docs/tarkes/pics/Ethernetpaket.png}
Ethernetpaket
\end{center}

Das Paket wird serialisiert und mit dem niederwertigsten Bit zuerst übertragen. Das Ethernetpaket besteht aus folgenden Teilen:
\begin{itemize}
\item Präambel und SFD\\
Dieser Teil des Paketes sind im Grunde nur Überbleibseln aus den alten Tagen. Die Präambel hat ein alternierendes Bitmuster über 7 Byte, während der SFD (Start Frame Delimeter) das Muster 10101011 trägt.\\
Diese Felder wurden früher benötigt um den einzelnen Devices eine Möglichkeit zu geben sich auf die Bitabstände zu synchronisieren.\\
Die große Länge der Präambel liegt darin begründet, dass beim passieren eines Repeaters oder Hubs immer ein Teil verloren ging. Um zu gewährleisten, dass auch bei maximal großen Netzwerken die Devices noch ein Minimum an Zeit haben sich zu synchronisieren, wurde die Länge auf 7 Bytes festgesetzt. 
\item Source- und Destination MAC-Adresse\\
Stehen für Quelle des Paketes und Empfänger des Paketes. (siehe Kapitel \ref{sssec:macaddr} auf Seite \pageref{sssec:macaddr})
\item VLAN-Tag\\
Der VLAN-Tag ermöglicht das auseinanderhalten von verschiedenen VLANs (siehe Kapitel \ref{sssec:vlan} Seite \pageref{sssec:vlan})
\item Typ Feld\\
Das Typ Feld oder EtherType Feld legt fest welches Protokoll sich in der Payload befindet. So steht zum Beispiel der Wert 0x0800 für IP oder 0x0806 für ARP.
\item Payload\\
Die Payload oder Nutzlast ist die Nachricht die das Ethernetframe mit sich nimmt. Diese kann nicht größer als 1500 bytes sein.
\item Pad bytes\\
Die Pad oder Padding bytes sind dazu da das Ethernet Paket auf eine minimale Größe von 64 bytes zu bringen, da es bei den früheren Varianten ansonsten zu Problemen mit der Collissiondetection gegeben hätte.
\item FCS feld\\
Das FCS (Frame Check Sequence) Feld beinhaltet eine 32 bit CRC Prüfsumme welche aus den Werten des reinen Layer2 Frames besteht. Also den bits von der MAC-Adresse bis hierher.
\end{itemize}

\subsection{Address Resolution Protocol - ARP}\label{ssec:arp}
ARP ist ein essentielles Protokoll für die Kommunikation in einem Netzwerk. Da, damit Kommunikation stattfinden kann, die MAC-Adresse bekannt sein muss, wurde dieses Protokoll eingestellt.\\
Es funktioniert indem ein Broadcast in das Netz geschickt wird, indem die Bitte steht, dass ein Host mit einer gewissen IP doch seine MAC-Adresse übermitteln soll. Diese speichert der PC der die Anfrage gestellt hat, in seinen lokalen Cache damit er nicht jedes mal nachfragen muss.\\
Dieses Protokoll wird mit der Verbreitung von IPv6 aussterben da in IPv6 das sogenannte Neighbour Discovery Protocol NDP diese Aufgabe übernimmt.\\

Das ARP Paket befindet sich gleichzeitig auf Layer 2 und 3 und sieht wie folgt aus:\\
\begin{itemize}
\item Hardwareadresstyp\\
Die Zahl in diesem Feld bestimmt den Typen der MAC-Adresse. Dies ist meistens Ethernet, was mit einer 1 repräsentiert wird.
\item Protokolladresstyp\\
Der Adresstyp für den die MAC-Adresse angefordert wird. Im Falle von IP ist dies 0x0800. Die Zahlen in diesem Feld teilen sich ihre Nummern mit dem EtherType beim Ethernet Protokoll.
\item Hardwareadresslänge\\
Die Länge der aufgelösten Adresse. Für Ethernet ist sie 6.
\item Protokolladresslänge\\
Die Länge der Adresse die aufgelöst werden soll. Für IPv4 lautet sie 4.
\item Operation\\
Enthält eine Zahl, die angibt ob das Paket ein Request (1) oder eine Response (2) ist.
\item Quell MAC-Adresse
\item Quell IP-Adresse
\item Ziel MAC-Adresse\\
Enthält FF:FF:FF:FF:FF:FF, die Layer2 Broadcast Adresse.
\item Ziel IP-Adresse
\end{itemize}
Es gibt jedoch auch noch andere Arten von ARP Paketen. Dazu zählen der Reverse ARP welcher die MAC- in eine IP-Adresse auflösen kann oder der Gratuitos ARP, welche eine Nachricht darstellt, die unaufgefordert bekannt macht, welche MAC-Adresse man selbst hat.
\subsection{Internet Protocol - IP}\label{ssec:ip}
Das Internet Protokoll hat zwei Hauptaufgaben:
\begin{itemize}
\item Adressierung\\
Das Ziel der Adressierung auf dieser Ebene ist es, wie bereits zuvor besprochen, ein Gerät über mehrere Netzwerke hinweg eindeutig zu machen, um Pakete nicht nur innerhalb eines Netzwerkes sonder über mehrere Netzwerke hinweg ansprechen zu können.
\item Fragmentierung\\
Da Kommunikation sich ja meistens nicht mit nur einem Paket ausgeht, ist es wichtig, dass Kommunikationsstränge aufgeteilt werden können in mehrere kleine Pakete. Dies nennt man dann Fragmentierung. IP ist dafür zuständig, dass fragmentierte Pakete wieder zusammenfinden können, da es ja nicht heißen muss, dass nur eine einzige Kommunikation gerade am laufen ist.\\
Dies gilt jedoch nur mehr für IPv4, denn in IPv6 ist es nicht mehr vorgesehen, dass Pakete fragmentieren.
\end{itemize}
\subsubsection{IPv4}
IP Version 4 war der erste offizielle Standard des Internet Protocols.\\
Adressierung im Schema von IPv4 wurde bereits in Kapitel \ref{sssec:ipaddr} auf Seite \pageref{sssec:ipaddr} besprochen.\\

Es gibt einige gesonderte Adressbereiche in IPv4 welche nicht für die Öffentliche Nutzung Verwendbar sind. Dazu zählt:
\begin{itemize}
\item 10.0.0.0/8\\
Sogenanntes Class A Netz: 1 Netz mit 16.777.216 Adressen (erstreckt sich bis 10.255.255.255/8)
\item 172.16.0.0/12\\
Sogenanntes Class B Netz: 16 Netze mit jeweils 65.536 Adressen (erstreckt sich von 172.16.0.0/16 über 172.17.0.0/16 usw. bis 172.32.0.0/16)
\item 192.168.0.0/16\\
Sogenanntes Class C Netz: 256 Netze mit je 256 Adressen (erstreckt sich von 192.168.0.0/24 über 192.168.1.0/24 usw. bis 192.168.255.0/24)
\item 100.64.0.0/10\\
Der Sogenannte Shared Adress Range. Er ist speziell für Internet Service Provider und ihre Anforderungen beim NAT bestimmt und nicht für den normalen User gedacht.
\item 169.254.0.0/16\\
Link Local Adressbereich. Er wird verwendet wenn keine spezifische IP-Adresse einem Rechner zugewiesen wird. Damit sind auch zwei Clients in der Lage miteinander zu reden, wenn sie unkonfiguriert und ohne DHCP-Server entweder direkt durch Kabel oder über einen Switch verbunden sind.
\item 127.0.0.0/8\\
LoopBack. Dieser Adressbereich wird für Interfaces des Hosts selbst verwendet. 
\item ...\\
Es gibt noch einige Bereiche mehr aber es würde hier zu weit führen alle aufzuzählen. Sie können in der RFC6890 (zum Zeitpunkt des Schreibens aktuelle Version) nachgelesen werden.
\end{itemize}

Obwohl IPv4 im Grunde schon seit mehrere Jahren von IPv6 abgelöst wurde, sind bis heute die wenigsten Firmen und noch weniger Heimnetzwerke auf IPv6 umgestellt. Es wird also im Grunde noch überall IPv4 verwendet obwohl der Adressbereich ($2^{32} = 4.294.967.296$, abzüglich reservierter Adressen = 3.707.764.736) in dieser Version bereits vollständig aufgebraucht ist.\\

Dieser Problematik wurde mit einigen Zwischenlösungen begegnet. Das Protokoll NAT (Network Address Translation) ist eines dieser Behilfsmittel.\\
Der IPv4 Standard sie eine Aufteilung in öffentliche und private Netzwerke vor. Adressen welche aus dem Bereich der Privaten Netzwerke kommen, müssen nicht eindeutig sein und können so oft wie gewünscht verwendet werden. Durch ihre Mehrdeutigkeit sind sie jedoch auch nicht dazu geeignet, im Internet verwendet zu werden, sondern sie sind für den privaten Gebrauch gedacht, daher auch Privates Netzwerk.\\
Will man nun aus seinem privaten Netz raus in das Internet, wendet jener Router welcher das private Netz mit dem des Providers verbindet, NAT an.\\
Er legt dabei eine Tabelle an in welcher die private Adresse sowie der Port steht, und ersetzt diese durch eine öffentliche Adresse und einen beliebigen anderen High Port. Die Antworten weißt er anhand des Ports dann wieder der richtigen privaten Adresse zu und leitet diese vom Internet zu dem Host der die Anfrage abschickte.\\
Dadurch scheint es als würden mehrere Hosts die gleiche IP-Adresse haben, nämlich jeder welcher über diesen Router das private Netzwerk verlässt.\\

Eine andere Art mit der das unausweichliche versiegen an Adressen versucht wurde hinauszuzögern, ist die dynamische Adressenvergabe von Providern an ihre Kunden.\\
Sieht man sich mithilfe von externen Tools die Adresse, welche man nach außen hat, an zwei verschiedenen Tagen an, kann es sein, dass sich diese unterscheiden.\\
Der Provider verwendet diese Methode um mehrere Kunden mit Adressen zu versorgen, als er eigentlich hat. Er geht dabei davon aus, dass zu keiner Zeit alle seine Kunden gleichzeitig online sind.\\

Das Problem entwickelte sich daraus, dass anfangs die Meinung geläufig war, es seien weitaus genug Adressen verfügbar. Deshalb hat man große Adressbereiche billig an Universitäten und Organisationen oder Firmen verkauft, ohne einen Gedanken daran zu verschwenden, dass womöglich irgendwann keine Adressen mehr übrig sein könnten.\\
Offiziell wurden im Januar 2011 die letzten beiden verfügbaren IPv4 Netze der RIR (Regional Internet Registry) von der IANA (Internet Assigned Numbers Authority) zugewiesen, welche diese nun an die einzelnen Länder aufteilen.\\

Warum die Verwendung des IPv6 Standards trotzdem soweit hinausgezögert wird, liegt an der Starre der Firmen. Die Umstellung auf IPv6 bedeutet viele Probleme, da, obwohl er bereits von fast jeglicher Hardware unterstützt, immernoch Kompatibilitätsprobleme mit sich bringt. Firmen sehen keinen Sinn darin viel Geld zu investieren um etwas zu implementieren was doch sowieso funktioniert.\\
\subsubsection{IPv6}
IPv6 ist der offizielle Nachfolger von IPv4. Er ist seit 1998 von der IETF standardisiert und bringt einige Neuerungen in das Internet Protocol welche die Fehler, welche durch das unterschätzte Wachstum des Internets hervorgerufen wurden aufheben soll.\\

Eine dieser Neuerungen, wahrscheinlich auch die wichtigste, ist der vergrößerte Adressbereich. Während IPv4 $2^{32}$, also etwas mehr als 4 Milliarden Adressen hat, verfügt IPv6 über $2^{128}$, umgerechnet über 340 Sextillionen oder $3,4 \cdot 10^{38}$ Adressen.\\
Ein anschaulicheres Beispiel bietet folgender Vergleich: Das Alter der Erde wird auf etwa 4,5 Milliarden Jahre geschätzt. Hätte man gleichzeitig mit der Entstehung der Erde begonnen mit einer Rate von 1 Milliarde Adressen pro Sekunde IPv6 Adressen aus dem vorhandenen Adressraum zu verteilen, wäre bis heute nur weniger als ein Billionstel des vorhandenen Adressraums vergeben.\\
Damit dürfte das Problem des Adressenmangels vorübergehend gelöst sein.\\

Weitere Vorteile sind das Anpassen der Headers an die neuen Anforderungen.\\
So ist Beispielsweise IPsec bereits im IPv6 selbst implementiert. Auch der Rechenaufwand für Router soll damit minimiert werden.\\

Eine Aufgabe die IPv6 nicht länger vollbringt wird das zuvor erwähnte Fragmentieren sein. Wenn ein Router ein Paket bekommt welches größer ist als sein MTU (Maximal Transition Unit), verwirft er das Paket und sendet ein ICMPv6 Paket mit der Meldung \glqq Too Big\grqq . Es ist nun die Aufgabe der Schichten darüber dafür zu sorgen, dass die Pakete welche sie versenden wollen nicht zu groß sind.\\

Die Adressnotation in IPv6 ist deutlich anderst als bei IPv4. Es gibt aufgrund der länge und schweren Handhabbarkeit der Adressen einige Vereinfachungsregeln, welche darauf abzielen die Adressen zu kürzen. Da die Adressen sehr viel länger sind, kommt eine dezimale Notation wie sie vorher Verwendung fand nicht mehr in Frage.\\
IPv6 verwendet daher Hexadezimale Notation, teilt die Adresse in 8 Blöcke auf und fasst in jedem Block 16 bit (=4Hexadezimalstellen) zusammen. Die Blöcke werden durch Doppelpunkte getrennt: \textbf{2001:0db8:85a3:08d3:2219:8a2e:0370:7344}\\
Führende Nullen dürfen dabei ausgelassen werden. \textbf{2001:0db8:85a3:08d3:0000:8a2e:0070:7344} entspricht also \textbf{2001:db8:85a3:8d3:0:8a2e:70:7344}\\
Kontinuierliche Blöcke aus 0 dürfen komplett ausgelassen werden und durch einen doppelten Doppelpunkt markiert werden. Diese Maßnahme darf jedoch nur einmal verwendet werden, da es sonst zu Mehrdeutigkeiten kommen kann. Beispiel: \textbf{2001:0db8:85a3:0:0:8a2e:0:0} darf entweder als \textbf{2001:0db8:85a3::8a2e:0:0} oder als \textbf{2001:0db8:85a3:0:0:8a2e::} geschrieben werden.\\

Die 128 bit lange Adresse wird in zwei 64 bit große Teile aufgeteilt. Ersterer ist der sogenannte Präfix.\\
Die letzten 64 bit jedoch sind der, für jede Netzwerkschnittstelle eindeutige \textbf{Network-Identifier}. Dieser wird anhand der MAC-Adresse ausgerechnet.\\
Daraufhin wurde Kritik aus der Internetgemeinde laut, da so die Anonymität des Internets vollständig verloren gehen würde. Die IETF hat daraufhin mit der RFC4941 die \textbf{Privacy Extensions} eingeführt, welche den Host selbstständig zufällig generierte Network Identifiers machen lässt. Dieser ist in den meisten Betriebssystemen standardmäßig aktiv.\\
Dies erhöht die Anonymität zwar, reicht aber noch nicht solang der Präfix, welcher meistens vom ISP vorgegeben wird, ebenso eindeutig ist. Sollte dieser ebenso dynamisch vergeben werden, ist ein guter Teil der Anonymität welche IPv4 hatte wieder gegeben.\\

Wenn eine IPv6 Adresse als URL verwendet werden soll, wird sie in eckige Klammern geschrieben, damit einer Verwechslung mit der Portnummer als Teil der Adresse vorgebeugt wird.\\

Da es keine privaten Netze mehr gibt, fallen viele reservierte Adressbereiche weg. Ein paar wesentliche sollen trotzdem genannt werden:
\begin{itemize}
\item ::1/128\\
Die LoopBack Adresse, entspricht 127.0.0.1 bei IPv4
\item fe80::/10\\
Link Local, entspricht 169.254.0.0 bei IPv4, wird verwendet für die Neighbour-Discovery und Autoadresszuweisungen.
\item 2000::/3 - 3fff::/3\\
Momentaner Bereich für global eindeutige Adressen.
\item 2001::\\
Werden den ISPs für ihre Kunden gegeben.
\item 2001:0db8::/32\\
Für Dokumentationszwecke
\item ...\\
Auch hier kann wieder in der RFC 6890 nachgelesen werden, um mehr zu erfahren.
\end{itemize}
\subsection{User Datagram Protocol - UDP}
Mit der Entwicklung von UDP wurde 1977 begonnen, als ersichtlich wurde, dass es notwendig ist ein Übertragungsprotokoll zu spezifizieren welches schneller war als TCP. UDP setzt auf IP auf und implementiert, gleich wie TCP, Ports.\\

Durch den Fokus auf die Geschwindigkeit der Datenübertragung wurden dafür an einigen anderen Punkten Abstriche gemacht. So ist es im Gegensatz zu TCP nicht Verbindungsorientiert, was bedeutet, dass es von sich aus nicht dafür Sorge trägt ob Pakete welche über das Netzwerk geschickt werden auch am anderen Ende ankommen, noch ob sie in da richtigen Reihenfolge ankommen.\\
Auch Sicherheitstechnisch ist keine Absicherung vorhanden. UDP ansich hat keine Vorkehrungen dafür getroffen, dass der Inhalt der Pakete geheim bleibt, bzw. dass er unverändert ankommt.\\

UDP hat trotz dieser Mängel große Bedeutung. Anwendungen bei denen das Fehlen von einzelnen Paketen nicht allzu schlimm ist wie zB VoIP (Voice over IP) oder bei denen nur kurze Paketwechsel stattfinden, ein Verbindungsaufbau also nur übermäßig Traffic erzeugen würde, wie zB DNS.\\

Der UDP Header beinhaltet folgende Werte: 
\begin{itemize}
\item Source Port
\item Destination Port
\item Länge
\item Checksum\\
In diesem Feld wird eine Prüfsumme vom Header und dem Paket erzeugt. In IPv4 ist dies noch optional, bei IPv6 nicht mehr.
\end{itemize}
\subsection{Transmission Control Protocol - TCP}
Die Entwicklung von TCP dauerte einige Jahre. Es begann bereits 1973 endete aber erst 1981 mit der Veröffentlichung der RFC 793. TCP ist ein zuverlässiges, verbindungsorientiertes Protokoll. Es stellt damit sowohl Flusssteuerung und Staukontrolle als auch das vorhanden sein aller Daten in der richtigen Reihenfolge sicher.\\

\begin{center}
\includegraphics[scale=0.6]{../docs/tarkes/pics/TcpHandshake.png}
\end{center}

Da TCP ein verbindungsorientiertes Protokoll ist, gibt es auch einen Verbindungsaufbau.\\
Dieser findet mittels eines \textbf{Three-Way-Handshake} statt: Zuerst wird vom Client ein SYN Paket (ein Paket bei welchem das SYN-Flag im Header gesetzt ist) an den Server geschickt. Der Wert im Sequence-Feld ist dabei zufällig gewählt.\\
Der Server schickt dann ein SYN-ACK Paket zurück, indem zusätzlich zu der SYN-Flag auch noch das ACK-Flag gesetzt ist. Im Acknowledge-Feld steht dabei der Wert des Sequence-Feldes des SYN-Paketes des Clients, während im Sequence Feld des SYN-ACK Paketes eine neue zufällige Zahl steht.\\
Das dritte Paket des Verbidnungsaufbaus ist dann das ACK-Paket des Clients an den Server. Darin ist nur noch das ACK-Flag gesetzt, im Sequence Feld steht der Wert des ersten Paketes + 1 und im Acknowledge Feld steht der Wert aus dem Sequence Feld des vorherigen Paketes.\\

Daraufhin ist der Verbindungsaufbau abgeschlossen und die Datenübertragung kann beginnen.\\
Dabei wird die Ordnung und Sicherheit, dass jedes Paket auch wirklich ankommt, dadurch erreicht, dass der Empfänger jedes Paket welches ihm in seiner Liste fehlt nocheinmal anfordert und das so oft bis er es auch bekommt. Ob ihm eines fehlt erkennt er anhand des Sequence Feldes.\\
Er buffert diese Pakete dann eine gewisse Zeit, um fehlende Pakete nachzuholen, doppelte zu Verwerfen und sie in Reihenfolge zu bringen.\\

Der TCP Header:\\
\begin{itemize}
\item Source Port
\item Destination Port
\item Sequence Number\\
Wie bereits zuvor erwähnt, dient diese dazu Ordnung halten zu können und um zu sehen ob doppelte oder vermisste Pakete existieren
\item Acknowledge Number\\
Für den Verbindungsaufbau
\item Data Offset\\
Größe des Headers, gibt den beginn der Nutzdaten an
\item Reserved\\
Wird nicht verwendet und muss 0 sein
\item Control Flags\\
Es gibt einige verschiedene Control Flags. Zwei davon, SYN und ACK wurden bereits erwähnt. Des weiteren gibt es noch beispielsweise FIN für den Verbindungsabbau, URG für urgent, also dringende Pakete oder RST für Reset.
\item Window \\
Die Menge an Daten die der Client zu empfangen bereit ist.
\item Checksum
\item Urgent Pointer\\
nur wichtig falls das URG Flag gesetzt ist
\item Options\\
Hier kann noch alles mögliche ausgemacht werden welches nicht im Standartheader steht.
\end{itemize}
\subsection{Dynamic Host Configuration Protocol - DHCP}
DHCP dient, wie der Name bereits aussagt, der dynamischen Konfiguration von Hosts. Standardmäßig hat jeder normale Enduser in dem WLAN Router, welchen er von dem ISP bereitgestellt bekommt, einen DHCP-Server. Dieser nutzt jedoch nur die grundlegendsten Funktionen des DHCP Protokolls, die Vergabe einer IP-Adresse und eines Standard Gateways.\\
DHCP ist jedoch zu weit mehr in der Lage. Die Optionen reichen von hostnamen über Proxy Einstellungen bis zu Zeitservern. Im Grunde sind die Optionen zur Konfiguration jedoch sogar unbegrenzt, da im Optionen Feld des Paketes eigene Dinge spezifiziert werden können.\\

Der Ablauf einer Kommunikation zwischen Host und DHCP-Server sieht wie folgt aus:\\
Ein Client, ahnungslos und ohne eigene Adresse, schreit in das Netzwerk, ob denn ein DHCP Server existiert welcher ihm eine Konfiguration anbieten möchte. Dieses Paket ist das DHCPDISCOVER.\\
Niemand, einer oder mehrere Server, je nach Bestückung des Netzwerkes, antworten nun mit einem DHCPOFFER in denen sie eine Konfiguration anbieten.\\
Der Client wählt nun eine der angebotenen Konfigurationen, und teilt das dem Netzwerk mit einem DHCPREQUEST mit.\\
Der Server, welchem der Request giltet, kann dieser nun mit DHCPACK für Acknowledge zustimmen oder mit DHCPNACK für Not Acknowledge ablehnen.\\

\subsection{Domain Name System - DNS}
DNS ist ein Protokoll welches zwar nicht zwangsweise notwendig ist für das Funktionieren des Internets, es aber uns Menschen sehr komfortabel macht es zu benützen.\\
Jeder ist heutzutage gewohnt, durch simples eintippen eines Namens, zu einer Seite zu kommen. Dies wird jedoch erst durch DNS möglich. Ein PC selbst kann mit dem Namen nichts anfangen, er muss ihn auflösen. Dafür schickt er den Namen zu seinem eingetragenen DNS Server und bittet ihn um die zugehörige IP-Adresse.\\

Würde nun jedoch jeder DNS Server jeden Namen mit dazugehöriger IP-Adresse speichern, würde es sehr schnell außer Hand geraten. Deshalb ist DNS hierarchisch designed. Das bedeutet, dass ein DNS-Server nur für einen gewissen Bereich zuständig ist. Weiß er nicht weiter, geht er die Leiter solange hinauf bis er schließlich jemanden findet der, wenn er auch vielleicht den Namen nicht weiß, ihn zu dem führen kann der ihn weiß.\\
Das kann schlimmsten Falls bei einem der Root Namens Server enden, der höchsten Autorität.\\

Zum besseren Verständnis sollte eine typische URL erklärt werden:\\
\textbf{www.example.com} besteht aus mehreren Bestandteilen.
\begin{itemize}
\item .\\
Nach dem kompletten Namen ist eigentlich ein Punkt der jedoch inzwischen ausgelassen werden kann
\item com\\
Die Top Level Domain \glqq com\grqq . Zu den Top Level Domains gehören auch die Länder Domains wie zum Beispiel at, us, jp und so weiter. Eine Domain ist eine Zusammenfassung von mehreren verschiedenen Untergruppen. So indiziert die Länder Domain at, dass alle URLs welche auf diese Top Level Domain enden, in Österreich ihren Standpunkt haben.
\item example\\
example wäre in diesem Beispiel eine Subdomain. Häufig werden Subdomains von Firmen und Organisationen gekauft. 
\item www\\
Obwohl das dreifache w im Internet immer mehr verloren geht, haben sie eigentlich eine wichtige Bedeutung. Sie sind der Host in dieser Gruppe an Hosts welche sich in einer Domain befinden, auf den man zugreift. Erst hier spitzt sich der Name auf einen Server zu. 
\end{itemize}
Nun wird auch ersichtlich warum ein hierarchisches System sinnvoll ist.\\

Dies wird auch vom Staat genutzt um Zensur zu betreiben. Die Filme und Serien Streaming Seite kinox.to wurde aus den DNS Servern in Deutschland gelöscht, als Konsequenz auf die Urheberrechtsverletzungen.
\subsection{Internet Control Message Protocol - ICMP}
Das Internet Control Message Protocol bewegt sich auf Layer 3 zusammen mit IP. Es dient dazu anderen Geräten Informationen über beispielsweise ihren Status zukommen zu lassen. Es gibt eine Variante für IPv6 das sogenannte ICMPv6. Es verwendet zum Transport IP obwohl es auf dem gleichen Layer liegt, da es sich als ein Protokoll höherer Ebene interpretiert.\\

Der Header des ICMP Paketes ist sehr klein. Er besteht lediglich aus:
\begin{itemize}
\item Type\\
Stellt die Art des ICMP dar. Kann zB 3 für \glqq Ziel nicht erreichbar\grqq  sein.
\item Code\\
Bietet eine genauere Auflösung der Art. Wenn der Typ zB 3 ist, gibt es die Codes 0 für Netzwerk nicht erreichbar, 1 für Host nicht erreichbar, 2 für Protokoll nicht erreichbar und noch einige andere
\item Checksum
\item Daten
\end{itemize}

Wichtige Beispiele für seine Funktionen sind die Meldungen Host Unreachable oder Destination Port Unreachable für die Berichterstattung, es gibt aber auch Analysefunktionen wie traceroute oder den ICMP Echo Request. 
\subsubsection{ICMP Echo Request/Response - Ping}
lorem ipsum
\subsection{File Transport Protcol - FTP}
lorem ipsum
\subsection{Simple Network Managing Prorocol - SNMP}
lorem ipsum
\subsubsection{Management Information Base}
lorem ipsum
\subsubsection{SNMPv2/SNMPv2c}
lorem ipsum
\subsubsection{SNMPv3}
lorem ispum
\subsection{Hypertext Transfer Protcol - HTTP}
lorem ipsum
\section{Netzwerksicherheit}
lorem ipsum
\subsection{MAC-Spoofing}\label{ssec:mspoof}
lorem ipsum
\subsection{MAC-Flooding}\label{ssec:mflood}
lorem ipsum

\chapter{E-Mail von Singh Manpreet}
lorem ipsum
\section{Allgemein E-Mail und Notification}
lorem ipsum
\subsection{Senden}
lorem ipsum
\subsubsection{Graphische Erklärung}
lorem ipsum
\subsection{Empfangen}
lorem ipsum
\subsubsection{IMAP}
lorem ipsum
\subsubsection{POP}
lorem ipsum
\section{E-Mail}
lorem ipsum
\subsection{Ursprung/Entstehung}
lorem ipsum
\subsection{Bedeutung heute}
lorem ipsum
\subsubsection{Zukünftig}
lorem ipsum
\subsection{Probleme}
lorem ipsum
\subsubsection{Kleine Probleme}
lorem ipsum
\subsubsection{Große Probleme - Gefahren}
lorem ipsum
\subsection{Sicherheit}
lorem ipsum
\subsubsection{Versuche}
lorem ipsum
\subsubsection{Was kann ich tun?}
lorem ipsum

\chapter{Oberfläche}
lorem ipsum
\section{Allgemein User Interface (UI) von Manpreet Singh}
lorem ipsum
\subsection{Geschichte}
lorem ipsum
\subsection{UIs}
lorem ipsum 
\subsection{Zukünftig}
lorem ipsum 
\section{Grahpical User Interface (GUI) von Manpreet Singh}
lorem ipsum
\subsection{Bedeutung}
lorem ipsum
\subsection{Wichtigkeit}
lorem ipsum
\subsubsection{Marktführende}
lorem ipsum
\subsubsection{Wichtige Operating System GUIs}
lorem ipsum
\subsection{Vor- und Nachteile}
lorem ipsum
\subsection{Möglichkeiten der Realisierung}
lorem ipsum
\subsection{Genauer}
lorem ipsum
\subsubsection{Realisierung}
lorem ipsum
\subsubsection{Graphikkarte oder Prozessor}
lorem ipsum
\section{Command Line Interface (CLI) von Alin Porcic}

\subsection{Allgemeines}

CLI steht für 'Command Line Interface' (text-basierende Schnittstelle) und darunter versteht man Schnittstellen, die die Eingabe eines Nutzers in Form von Text interpretiert und diese dann ausführt.

\subsection{Geschichte}

Die Interaktion mit Computerv vor der Erfindung der Video-Display-Terminals wurde außschließlich über text-basierende Schnittstellen implentiert. Auch nach der Einführung der Video-Display-Terminals wurden die CLIs weiter verwendet, speziell bei unix-ähnlichen Betriebssystemen und anderen Systemen, wie z.B. MS-DOS, CP/M und Apple DOS. Die CLI wurde als eine sogenannte 'Command-Line-Shell' implementiert. Die Shell war ein Programm, dass die Benutzereingaben einliest und in Betriebssytem-Funktionen umwandelt.\\
Die gewöhnlichen Benutzer bevorzugen die grafischen Schnittstellen als die text-basierende. Erfahrene Anwender greifen auch heute immer noch zur CLI, da sie oftmals eine mächtigerer Kontrolle über Programme und dem Betriebssystem bietet als grafische Schnittstellen. (vgl. Wikipedia CLI)\\

\subsection{Vor- und Nachteile}

In CLI-Anwendungen lassen sich viel mehr Einstellungen vornehmen als bei grafischen Anwendungen, ein gutes Beispiel hierführ ist der C/C++ Compiler 'gcc'. Eine grafische Oberfläche für die Benutztung dieses Compilers müsste enorm viele Einstellungen und Textfelder bieten, um den Compiler bis ins Detail zu konfigurieren. Da die Umsetztung einer Oberfläche für den 'gcc' seh schwierig und auch sinnlos ist, werden in moderenen IDEs einfach eine Konsole eingebaut, die für die Verwendung des Compilers verwendet wird.\\

Der sicherlich größte Nachteil der CLI ist das der Benutzer die Befehle, die Parameter und die Argumente kennen muss. In seltenen Fällen müssen sogar die Parameter in der richtigen Reihenfolge eingeben werden. Multimedia-Daten lassen sich nur schwer über die Konsole verwenden, auch das Surfen im Internet erweist sich als schwierig.

\chapter{Datenbank von Stojanovi\'{c} Marko}

\section{Allgemeines}
Datenbanken sind für die Verwaltung von digitalen Daten zuständig. Heute stellen Datenbanksysteme einen zentralen Punkt im IT-Bereich der Unternehemen. Dadurch ist ein Unternehmen auf die Verfügbarkeit, Vollständigkeit und Richtigkeit der Daten angewiesen. Dadurch ist sicher zu stellen, dass die Datensicherheit gewährleistet ist, dies wird gesetzlich oder durch eine Behörde vorgeschieben.\\

Zum Aufgabenbereich eines Datenbanksystems gehören speichern, lesen, löschen und ändern von Dateien. Dies muss für große Datenmentgen effizient, widerspruchsfrei und dauerhaft gewährleistet sein. Auch geforderte Teilmengen müssen für Benutzer und Anwendungsprogramme in verschiedensten Darstellungsformaten bereitgestellt werden können.

Datenbanksysteme setzen sich grundsätzlich aus zwei Teilsystemen zusammen.

\begin{itemize}
\item Datenmanagementsystem (DBMS)\\
Dieses System ist für jegliche Organisationen zuständig.
\item Datenbank\\
Als Datenbank wird die Menge bzw. Sammlung aller Daten bezeichnet.
\end{itemize} 

Es gibt verschiedene Datenbankmanagementsystemmodelle.
\begin{itemize}
\item ralatinales DBMS
\item netzwerkartiges DBMS
\item hierarchisches DBMS
\item objektorientiertes DBMS usw.
\end{itemize}

Datenbanken werden für alle Webseiten zur Datenverwaltung verwendet ( z.B.: Regristrierungen, Einkäufe wie bei z.B.: ebay, amazon ).
Microsoft Access und OpenOfficeBase eignen sich gut für kleinere Datenbanken (z.B.: kleinere Büros), weil die Handhabung durch die grafische Darstellung sehr leicht zu bedienen ist und den Mitarbeitern Schulungen erspart bleiben.
Diese eignen sich jedoch nicht als Datenbanken für Webdienste ( z.B. Facebook, Twitter, ebay, ... ).\\

Häufig wird die Porgrammiersprache SQL (Structured Query Language) zur Erstellung einer Datenbank verwendet. Dabei ist bei der Erstellung von einer Datenbank zu beachten, dass keine Information mehrfach angegeben wird. Jede Information darf nur einmal vorkommen!

\section{Geschichte}
Bereits in den 1960er Jahren gab es Probleme beim Verarbeiten von Daten in einfachen Dateien. Damals wurde eine eine Lösung entwickelt, bei der eine weitere Softwareschicht eingeschoben wurde. Diese lag zwischen der Dateiverwaltung (Betriebssystem) und den Anwendugsprogrammen. Dieser Lösungsversuch setzte sich jedoch nicht durch, da Datenspeicher in Form von Dateien individuell für einzelne Anwendungen erstellt wurden. Die Folge war, dass viel Zeit und Leistung zum Umkopieren, Mischen und Restrukturieren der Dateien in Anspruch genommen werden musste.\\

In den 1966 bis 1968 wurde IMS (Information Management System) von IBM, North American Rockwell und Caterpillar Tractors für das Apollo-Mondprogramm entwickelt, zur Verwaltung der Stücklisten, die verwalteten Datenbanken waren hierarchisch strukturiert. IMS gehört zu den ersten großen Datenbankmanagementsystemen (DBMS) mit der Sprache DL/I (Data Language One). IMS wurde vom Entwickulungsstart bis 1969 unter dem Name  ICS (Information Control System) geführt. Heute wird IMS hauptsächlich für Banken und Versicherungen eingesetzt.\\

Zur gleichen Zeit wurde von CODASYL (COnference on DAta SYstems Languages) ein Nerwerk- Datenbanksystem entwickelt.\\

1970 wurde ein weiterer Fortschritt von Edgar Frank Codd erzielt. Im Rahmen einer Forschungsarbeit am IBM Almaden Research Center wurden die Grundlagen des ersten relationalen Datenbanksystems (System R) von Codd vorgestellt. Mit Open Source relationalem Datenbanksystem Ingres ( interactive graphics retrieval system) und der Abfragesprache QUEL folgte die Berkeley Groupe.\\

Oracle (damals SDL und RSI) nutzte Ergebnisse von System R und brachte SQL den Erfolgt. SQL/DS und DB2 folgen von IBM.\\

Trotz einiger Kritikpunkte wurden in den 1980er Jahren hierarchische und netzwerkartige Systeme von vielen Behörden, Konzenen, Instituten und auch kleineren Unternehmen durch das relationale Modell ersetzt. Bis zu den 2000er Jahren als Open-Source-Datenbankmanagementsysteme an Bedeutung erlangen gab es keine großen Veränderungen. Die größten Markanteile wurden von MySQL und PostgreSQL erzielt.
Als Reaktion von führenden Herstellern wurden gratis Versionen ihrer Datenbank-Programme angeboten.\\

Seit 2001 wurde  NoSQL bekannter und erzielte ebenfalls an Bedeutung, da sich mit einem nicht-relationalen Konzept durchsetzt.
\section{Definitionen}
\begin{itemize}
\item Datenfeld
\item Datensatz
\item Schlüssel
\item Primärschlüssel
\item Sekundärschlüssel
\item Stellvertretende Schlüssel
\item Fremdschlüssel

\end{itemize}
\section{Effizienz}
lorem ipsum
\section{Funktionen}
lorem ipsum
\subsection{Anwendungen}
lorem ipsum
\section{Datenbanksysteme}
Ein Datenbanksystem besteht immer aus einem DBMS und der dazugehörigen Datenbank. Ein Datenbanksystem muss gewähleisten, dass auf Festspeichern abgespeicherte Daten auch nach einem unvorhergesehenen Ausfalls des Systems (z.B.: Stromausfall) wieder ohne Veränderungen und Verluste aufgerufen werden.\\
Es bietet eine Schnittschnelle zwischen dem DBMS und der Datenbankanwendung zur  Abfrage, Auswertung, Veränderung und Verwaltung an.

\subsection{Datenbankmanagementsysteme}
Das DBMS ist die Verwaltunssoftware, welche für die Organisation der stukturiertten  Speicherung der Daten und zur Kontrolle der gesamten Lese, Lösch- und Schreibzugriffe auf die Datenbank zuständig ist.
Diese Software wird für das Datenbanksystem installiert und konfigureiert und durch diese Software wird auch das Datenbankmodell bestimmt.
Da die Funktonalität und die Geschwindigkeit von DBMS abhängen ist die Auswahl oftmals gut zu durchdenken.
DBMS sind hochkoplexe Softwaresysteme.\\

RDBMS wird oft als Abkürzung verwendet, weil das relationale DBMS am meisten Verwendung findet.

\subsection{Datenbank}
Theoretisch ist eine Datenbank ein zusammgehöriger Datenbestand. 
Diese Datenmenge wird auf einen Festspeicher abgelegt und für alle Anwendungen für den Benutzer von einem DBMS zur Verfügung gestellt.

Zu beachten ist, dass unter Datenbank oft das DBMS und die Daten gemeint werden, nicht die dazugehörige Dantenbankanwendungssoftware. Diese besteht oft aus Computerprogrammen, welche über ein Datenbanksystem ihre notwendigen Daten speichern.
\\"Beispiele: Auftragsverwaltung und Bestellwesen, Kunden- und Adressverwaltung, Rechnungserstellung."

\section{Relationales Datenbankmanagementsystem (RDBMS)}
Das relationale Datenbanksystem findet in der Praxis am häufigsten Verwendung.
Bei Relatinalen Datenbanksystemen können Felder aus verschiedenen Tabellen durch einen Primärschlüssel verbunden werden.
lorem ipsum
\subsection{Prinzip eines RDBMS}
lorem ipsum
\subsection{Tabellen}
lorem ipsum
\subsection{Alternative Datenbankmanagementsysteme}
lorem ipsum
\subsubsection{Information Management System}
lorem ipsum
\subsubsection{Netzwerkdatenbankmodell}
CODASYL war Entwickler von standardisierten Verfahren zur Definition der Struktur und Bearbeitungaußerdem die Programmiertsprache COBOL. 
lorem ipsum
\subsubsection{Hierarchisches Datenbankmodell}
lorem ipsum
\section{Zugriffe}
lorem ipsum
\subsection{Zugriffsmöglichkeiten}
lorem ipsum
\subsection{Sicherheit}
lorem ipsum
\subsection{Gleichzeitige Zugriffe}
lorem ipsum 
\section{Sprachen}
lorem ipsum
\subsection{Verwaltungsgetrennte Sprachen}
lorem ipsum
\subsubsection{Abfragen und Manipulieren der Daten}
lorem ipsum
\subsubsection{Datenbankstruktur}
lorem ipsum
\subsubsection{Berechtigungen}
lorem ipsum
\subsection{SQL}
lorem ipsum
\section{SQLite}
lorem ipsum
\subsection{Geschichte}
lorem ipsum
\subsection{Eigenschaften}
lorem ipsum
\subsection{Datentypen}
lorem ipsum
\subsection{Syntax}
lorem ipsum 
\subsection{Befehle}
lorem ipsum
\subsection{Vor- und Nachteile}
lorem ipsum
\subsubsection{Vorteile}
lorem ipsum
\subsubsection{Nachteile}
lorem ipsum

\chapter{Kryptologie von Porcic Alin}\label{chap:krypto}
\section{Allgemeines}

Die Kryptologie, eine sehr alte Kunst und Wissenschaft, die sich mit der Informationssicherheit befasst, hat in der heutigen modernen Zeit einen sehr wichtigen Stellenwert eingenommen und ist nicht mehr wegzudenken. Unzählige Informationen werden weltweit kreuz und quer ausgetauscht und dabei kommt es öfter vor, dass die zu übertragenen Informationen einen hohen wirtschaftlichen Wert haben können. Dieser Wert der Informationen geht dann verloren, wenn ein Unbefugter die Aussage dieser Informationen verstehen kann. Damit das nicht passiert, werden kryptogrphische Systeme entwickelt, um die Lesbarkeit von Informationen zu verhindern bzw. zu erschweren.\\

Die Fähigkeit von diesen Systemen Informationen vor wirtschaftlichen Schäden zu schützen, werden mit der Informationssicherheit bezeichnet. Die Minimierung von Risiken, der Schutz vor Bedrohungen und die einhaltung der Schutzziele sind ebenfalls Anforderungen der Informationssicherheit. Für die Einhaltung der Ziele der Informationssicherheit werden folgende Schutzziele definiert:

\begin{itemize}
\item Vertraulichkeit (Englisch: confidentiality): Die Vertraulichkeit gibt an, dass die Ausage der Informationen vor unbefugten Personen geschützt ist und nicht modifiziert werden kann.
\item Integrität (Englisch: integrity): Die unbemerkte Veränderung von Informationen darf nicht möglich sein.
\item Verfügbarkeit (Englisch: availability): Der Zugriff auf die Daten muss innerhalb eines vereinbarten Zeitraumes gewährleistet sein.
\item Authentizität (Englisch: authenticity): Die Echtheit eines Objektes kann bewiesen werden, daraus folgt, die Überprüfung der Vertrauenswürdigkeit eines Objektes kann festgestellt werden.
\item Verbindlichkeit/Nichtabstreitbarkeit (englisch: non repudiation): Die durchgeführeten Handlungen können nicht vom Ausführenden abgestreitet werden.
\item Zurechenbarkeit (englisch: accountability): Die Ausführung einer Handlung kann einem Kommunikationspartner eindeutig zugewiesen werden.
\item in bestimmten Kontexten auch die Anonymität
\end{itemize}

(vgl. Wikipedia - Informationssicherheit)\\\\

Verfahren, Informationen zu verstecken, sind nichts neues - die ersten Ansätze und Anwendungen von kryptographischen Systmen reichen weit in die Vergangenheit der Menschheit zurück. Schon seit 2500 sind Methoden bekannt die Lesbarkeit von wichtigen Informationen zu verhindern. In Sparta als Beispiel hat die Regierung ein Pergament Band um einen Zylinder spiralförmig aufgespannt und die zu ermittelnde Nachricht über die verschiedenen Ringe des Pergaments geschrieben. Die Entschlüsselung gelang nur dann, wenn man einen Zylinder mit dem gleichem Durchmesser besaß (siehe MONOALP).\\

Das einfache Surfen im Internet, das Abrufen und Versenden von E-Mails, E-Banking, die Abspeicherung von Passwörtern - alle diese Dinge werden mithilfe von kryptographischen Verfahren sichergestellt. Ohne es zu bemerken, verwenden und verlassen sich milliarden von Menschen auf solche Verfahren.

\section{Kryptographie}

Mit Kryptographie ist die Entwicklung von kryptografischen Systemen gemeint.

Die Sicherheit eines kryptographischen Systems darf nicht von der Geheimhaltung des Algorithmus abhängen. Nur die Geheimhaltung der Eingangsgrößen des Algorithmus soll die Sicherheit gewehrleisten. \textbf{Security through obscurity} (= Sicherheit durch Obskurität) ist einer der wichtigsten Leitgedanken für kryptographische Systeme nach dem Kerckhoffs' Prinzip (oder Kerckhoffs' Maxime). Das Kerckhoffs' Prinzip definiert weiter wichtige Grundsätze, die ein modernes kryptographisches System erfüllen sollte. (vgl. Wikipedia - Kerckhoffs' Prinzip)\\\\

\subsection{Geschichte der Kryptographie}

\subsubsection{Klassische Kryptographie}

\paragraph{Monoalphabetische Chiffrierung}

Vor mehr als 2500 Jahren hat man einen \textbf{Skytale} für die Verschlüsselung von Informationen verwendet. Man hat ein Pergamentband oder einen Lederstreifen spiralförmig um den Skytale gewickelt und die zu verschlüsselnde Nachricht über die einzelnen Ringe der Streifen geschreiben. Nun konnte man das Band bei der Übermittlung abgefangen werden, doch ohne den richten Skytale nicht entschlüsselt werden. Nur der Empfänger, der im Besitz eines Skytales mit gleichem Durchmesser war, kann die für ihn bestimmte Nachricht entschlüsseln. Dieses Verschlüsselungssystem ist symmetrisch, da für die Ver- und Entschlüsselung der Durchmesser des Skytales unverändert bleibt. Der Durchmesser des Skytales wird in diesem Verfahren als der Schlüssel bezeichnet. Kennt man den Schlüssel, so kann man, sofern das kryptografische System bekannt ist, entschlüsselt werden. (vgl. Kryptologie, Thomas Imboden, Seite 15-16)\\\\

Ein weiteres monoalphabetisches Verfahren ist die \textbf{Caesar-Verschlüsselung}. Dieses Verfahren verschob alle Buchstaben des Klartextalphabets um eine bestimmte Zahl. Der Kommunikationsparnter musst über die Anzahl der Verschiebungen informiert sein, da dieser sonst den Text nicht entschlüsseln konnte. Der Schlüssel, also die Anzahl der Verschiebungen, musste dem Kommunikationsparnter über einen sicheren Kanal übermittelt werden.\\\\

Die Tauschchiffre funktioniert ähnlich wie das Caesar-Verfahren, wurde aber ein bisschen erweitert. Die Buchstaben werden als Zahlen dargestellt, da das Rechnen mit Zahlen einfache ist (LOL). Der Buchstabe 'A' wird meistens mit der Zahl 1 repräsentiert, 'B' mit der Zahl 2, 'X' mit der Zahl 25 und 'Z' mit 0. Die Verschiebung der Buchstaben um drei Stellen, erfolgt durch eine Addition mit 3. Der Tauschchiffre geht wie folgt vor, um einen Klartext in Geheimtext zu übersetzten:

\begin{itemize}
  \item Klartextalphabet in Zahlen übersetzten
  \item die Zahlen mit einer konstanten Zahl addieren (z.B. 3)
  \item die neue Zahl durch die Anzahl der Buchstaben dividiert
  \item der Rest dieser Division (modulo) stellt den Buchstabe des verschlüsselten Textes dar
\end{itemize}

Dieses Verfahren ist deutlich schwieriger zu Entschlüsseln als die Caesar-Verschlüsselung. Jedoch kann dieses Verfahren auch über Häufigkeitsberechnungen entschlüsselt werden, da jeder Buchstabe gleich verschlüsselt wird.\\\\

Eine andere Art von monoalphabetische Chiffre sind die Schlüsselwörter. Für die Verschlüsselung wird ein Schlüsselwort und Schlüsselbuchstabe definiert. Nun werden gleiche Buchstaben aus dem Schlüsselwort herausgenommen und das Schlüsselwort wird in das Klartextalphabet an der Stelle des Schlüsselbuchstabe hineingesetzt. \\\\

\paragraph{Polyalphabetische Chiffrierung}

Die \textbf{Vigenère-Chiffre} wurde 1586 von dem Franzonsen 'Blaise de Vigenère' in die Welt gesetzt. Damit man einen Text verschlüsseln konnte brauchte man als erstes ein Schlüsselwort und das Vigenère-Quadrat. In der ersten Zeile des Quadrats sind alle Buchstaben des Alphabets aufgelistet, beginnent mit A. In der zweiten Zeile ist das Alphabet aus der ersten Zeile um eine Stelle nach links verschoben, sodass der erste Buchstabe 'B' ist. In der letzten Zeile ist der erste Buchstabe das 'Z'. Nun wird das Schlüsselwort unter dem Klartext geschrieben und falls notwendig wiederholt:\\\\

\textbf{Klartext:      EINHAUSSTEHTAMWALDRAND}\\
\textbf{Schlüsselwort: KRYPTOKRYPTOKRYPTOKRYP}\\

Um den ersten Buchstaben zu verschlüsseln, muss man die Spalte des Quadrats suchen, die mit diesem Buchstaben beginnt. Dann sucht man sich die Zeile, die mit dem ersten Buchstaben des Schlüsselwortes übereinstimmt. Die Spalte und Zeile schneiden sich bei einem Buchstaben, welches der verschlüsselte Buchstabe ist.

Eine andere sehr bekannte polyalphabetische Chiffrierung ist 'ENIGMA'. ENIGMA wurde von den Deutschen nach dem Ersten Weltkrieg entwickelt, um die Funksprüche zu verschlüsseln. Die ENIGMA war eine umfunktionierte Schreibmaschine mit drei Walzen, die je nach setzten der Kontakte den Klartext verschlüsselten. Da sich die Walzen nach jeder Eingabe weiterdrehen, werden gleiche Buchstaben nicht gleich verschlüsselt. Die Alliierten konnten den 'ENIGMA'-Code durch die Turing-Bombe entschlüsseln.

\subsubsection{Moderne Kryptographie}

\subsection{Ziele der Kryptographie}

Kryptographische Systeme, die in der heutigen Zeit eingesetzt werden, müssen folgende Schutzziele einhalten, da sonst die Sicherheit der Informationen nicht gegeben ist: (vgl. Wikipeida - Kryptographie)

\begin{itemize}
\item Vertraulichkeit / Zugriffschutz (Englisch: confidentiality)
\item Integrität / Änderungsschutz  (Englisch: integrity) 
\item Authentizität / Fälschungsschutz (Englisch: authenticity)
\item Verbindlichkeit / Nichtabstreitbarkeit (Englisch: non repudiation) 
\end{itemize}

Die Vertraulichkeit der Informationen ist dann gegeben, wenn der Inhalt bzw. die Aussage der Informationen vor unbefugte Personen gesichert ist. Der Wert der Informationen soll sichergestellt werden.\\\\
Integrität sagt aus, dass die Daten auf dem Weg zum Empfänger nicht verändert werden können. Auch wenn der Inahlt der Informationen unbekannt ist, darf die Aussage der Informationen nicht durch verändern des verschlüsselten Textes geändert werden.\\\\
Der Verschlüsselungsalgorythmus kann noch so gut sein, wenn die Verschlüsselung mit dem falschen Parnter gemacht werden, kann keine Sicherheit gewahrt werden. Daher müssen sich die Kommunikationsparnter ausweisen, bevor irgendwelche Informationen ausgetauscht werden.\\\\
Die Verbindlichkeit besagt, dass ein Kommunikationsparnter seine gesendeten Informationen nicht abstreiten kann. Nur der Kommunikationsparnter kann die Informationen gesendet haben.

\subsection{Methoden}

\subsubsection{Klassische Methoden}

Methoden die nur mit Buchstaben oder Buchstabengruppen arbeiten, werden als 'Klassische Methoden' bezeichnet. Diese Methoden sind veraltet und unsicher.

\paragraph{Transposition}

Buchstaben des Klartextes werden anders angeordnet (siehe Skytale).

\paragraph{Substitution}

Die Buchstaben werden durch andere Buchstaben oder Symbole ersetzt (siehe Monoalphabetische Chiffreirung und Polyalphabetische Chiffrierungen).

\subsubsection{Moderene Methoden}

Moderne Methoden arbeiten mit Bits und nicht mit Buchstaben, daher können alle Arten von Binärdaten ver- und entschlüssetlt werden. Diese Methoden lassen sich in zwei große Gruppen aufteilen: die symmetrischen Verschlüsselungsmethoden und die asymmetrischen Verschlüsselungsmethoden.

\paragraph{Symmetrische Verschlüsselungsmethoden} Symmetrische Verschlüsselungsmethoden charakterisieren sich dadurch, dass sie für die Ver- als auch für die Entschlüsselung den gleichen Schlüssel verwenden. Diese Methoden bauen hauptsächlich auf Bitoperationen, Bit-Verknüpfungen und Substitution-Tabellen für Bitfolgen auf. Diese Methoden sind im Vergleich zu den asymmetrischen Methoden deutlich perfomanter und werden deshalb hauptsächlich für die Übertragung von größeren Daten verwendet.

\paragraph{Asymmetrische Verschlüsselungsmethoden} Asymmetrische Methoden benötigen für die Ent- und Verschlüsselung verschiedene Schlüssel. Die Sicherheit dieser Methoden bauen auf diskreten mathematischen Problematiken auf (z.B. elliptische Kurve, endlichen Körpern, ...). Sie sind nicht so perfomant und werden deshalb nicht für die Übertragung von größeren Daten verwendet. Diese Methoden werden hauptsächlich für Digitale-Signaturen, Zertifikaten und Key-Exchange verwendet.

\paragraph{Hashfunktionen} Hashfunktionen sind Funktionen, die einen Klartext in einen Hash wandeln kann, aber nicht mehr zurück. Dies wird oft bei der Abspeicherung von Passwörtern verwendet, aber auch bei Checksummen bei Daten oder Message-Authentication-Code. Hashfunktionen basieren auf ähnlichen Operationen wie die symmetrischen Methoden.

\section{Kryptoanalyse}

Die Krytpoanalyse beschäftigt sich mit Methoden und Techniken aus einem verschlüsselten Text Informationen zu gewinnen. Sie ist das Gegenstück zur Kryptographie und versucht das kryptographische System durch die Anwendung von bestimmten Methoden zu umgehen.

\subsection{Ziele der Kryptoanalyse}

Das oberste Ziel der Kryptoanalyse ist die Ermittlung des Schlüssels, um an den Wert der Informationen zu gelangen. Damit die Kryptoanalyse zum Ziel kommen kann, muss das kryptographische System ausgehebelt werden, entweder durch ausprobieren des Schlüssels oder anderen Methoden.

\subsection{Methoden}

\paragraph{Brute-Force-Methode} Bei dieser Art von Angriff werden alle möglichen Schlüssel ausprobiert. Dabei werden Schlüssel, die wahrscheinlich häufiger auftreten, als erstes ausprobiert. Oftmals ist nicht das Verschlüsselungssystem die Schwäche, sondern zu einfache gewählte Passwörter. Durch die Annahme, das der verwendete Schlüssel kurz und eine Kombination aus Wörtern und Zahlen ist, kann in den meisten Fällen der Schlüssel erraten und das Verschlüsselungssystem umgangen werden.

\paragraph{Wörterbuchangriff} Diese Methoden verwenden große Schlüsselsammlungen aus mehreren verschiedenen Sprachräumen und kann einfache Passwörter, die nur aus einem Wort bestehen, mit leichtigkeit Knacken.

\paragraph{Man-in-the-middle-Angriff} Der Angreifer sitzt zwischen den Kommunikationspartner und kann die Informationen in Klartext mitlesen und verändern.

\paragraph{...} Es gibt noch zahlreiche andere Methoden, doch auf die werden hier nicht mehr eingegangen. 

\section{Heutige Verschlüsselungsverfahren}

\subsubsection{Nennenswerte symmetrische Verschlüsselungssysteme}

\paragraph{DES}

DES wurde 1975 von IBM veröffentlicht und basierte auf den Verschlüsselungsalgorithmus 'Lucifer'. DES verwendet für die Verschlüsselung einen 64bit Schlüssel, der jedoch 8bit als Prüfsumme verwendet. Dieses Verschlüsselungsverfahren ist nicht mehr sicher, da die heutigen Computer die 56bit Schlüssel mit Brute-Force-Attacken innerhalb weniger Stunde knacken können.

\paragraph{3DES}

Triple DES ist der Nachfolger des DES-Standarts und wendet für die Ver- und Entschlüsselung DES dreimal an. Hierbei verwendet das Verfahren zwei 64bit Schlüssel, die abwechselend eingesetzt werden. Jedoch werden von den zwei 64bit Schlüssel bei dem Verfahren nur 112bit effektiv eingesetzt, da die restlichen Bits für Prüfzwecke benötigt werden. Dieses Verfahren gilt grundsätzlich noch als sicher,
doch es wird drigendst geraten auf einen Ersatz umzusteigen.

\paragraph{AES}

AES, der ausgewählte Nachfolger von DES), wurde im Oktober 2000 vom 'National Instite of Standards and Technology' als neuer Standard freigegeben. AES ist ein Blockchiffre und kann für die Verschlüsselung 128, 160, 192, 224 oder 256 Bit langen Schlüssel verwenden. Bis heute ist der AES-Standard nocht im Gebrauch und auch immer noch kryptographisch sicher.

\subsection{Asymmetrische Verschlüsselungsverfahren}

Asymmetrische Verschlüsselungsverfahren benötigten jeweils zwei verschiedene Schlüssel. Man unterscheidet zwischen zwei Schlüssel: den öffentlichen Schlüssel, den jeder haben darf, und den privaten Schlüssel, den nur der Erzeuger des Schlüsselpaars haben darf. Der öffentliche Schlüssel und private Schlüssel sind identisch, d.h. es kann auch der private Schlüssel veröffentlicht werden und der öffentliche Schlüssel als privater genutzt werden.

\subsubsection{Merkmale}

\paragraph{Digitale Signaturen}

Eine digitale Signatur (=digitale Unterschrift) ist eine Methode basierend auf den asymmetrischen Verschlüsselungsmethoden, die die Integrität und Nichtabstreitbarkeit im Netzwerk sicherstellt. Eine digitale Signatur kann nur mit dem Privat-Key erzeugt werden und die Entschlüsselung daher nur mit dem Public-Key. Kann die Signatur entschlüsselt werden, so weiß man, dass der Sender im Besitz des Privaten SChlüssels ist und derjenige ist für den er sich ausgibt. (vgl. http://de.wikipedia.org/wiki/Digitale-Signatur)

\paragraph{Digitale Zertifikate}

Digitale Zertifikate sind Ansammlungen von Daten, die mithilfe von kryptographischen Methoden Authenzität und Integrität der enthaltenen Informationen sicherstellen. Der weitverbreitete X.509-Zertifikat Standard z.B. bestätigt die Intentität des Inhabers, Richtigkeit des öffentlichen Schlüssels und nocht weiteren Informationen. Diese Zertifikate finden großen Einsatz in Webbrowsern. (vgl. wiki)

\subsubsection{Nennenswerte asymmetrische Verschlüsselungssysteme}

\paragraph{Diffie-Hellman}

Diffie-Hellman ist ein Austauschprotkoll, welches den Austausch eines geheimen Schlüssels erlaubt. Es ist praktisch unmöglich aus den gesendeten Informationen den Schlüssel zu berechen - dieses Problem wird als das Diffie-Hellman-Problem bezeichnet.

\paragraph{RSA}

RAS (Rivest-Shamir-Adleman) wird für Verschlüsselungen und digitale Signaturen verwendet.

\paragraph{ElGamal}



\subsection{Hybride Verschlüsselungsverfahren}

\subsubsection{Merkmale}

Hybride Verschlüsselungssysteme nutzen die Vorteile der symmetrischen und asymetrischen Systeme aus. Bei diesen Verfahren wird ein geheimer Schlüssel zwischen den Parntern mithilfe eines asymmetrischen Systems ausgemacht. Dieser Vorgang ist oftmals sehr rechenintensiv und wird daher nur einmal pro Sitzung durchgeführt. Nachdem der Schlüssel ausgetauscht wurde wird mit einem symmetischen System gearbeite, da diese sehr viel weniger Leistung vüf die Ver- und Entschlüsselungen benötigen.

\subsubsection{Nenneswerte hybride Verschlüsselungssysteme}

\paragraph{IPsec}

IPsec ist ein Sammlung an Protokollen und Verschlüsselungssystemen, die modular verwendet werden können, um eine sichere Kommunikation in einem unsicherem Netzwerk bieten soll. Im IP-Netzwerk können Rechner, die Packete weiterleiten, die Inhalte lesen und verändern. IPsec verhindert dies, indem es die IP-Packete kapselt und verschlüsselt. Damit kann kein Netzwerkgerät dazwischen die Inhalte lesen oder verändern. Desweiteren können Geräte nicht sehen an wen oder von wem das Paket stammt.

\paragraph{TLS/SSL}

TLS steht für \textbf{Transport Security Layer} (alte Bezeichnung: SSL, Secure-Socket-Layer) und wird bei HTTPS eingesetzt.

\paragraph{PGP}

PGP steht für \textbf{Pretty-Good-Privacy} und ist ein Programm, welches die Verschlüsselung und Entschlüsselung von Daten erlaubt. Der Sender erzeugt einen Schlüssel und verschlüsselt die Daten mit diesem Schlüssel. Nun verschlüsselt er den Schlüssel mit dem öffentlichen Schlüssel des Empfängers und sendet die verschüsselten Daten mit dem verschlüsselten Schlüssel an den Empfänger. Dieser braucht nur den Schüssel mit seinem privaten Schlüssel entschlüsseln und kann die Daten mithilfe des Schlüssels entschlüsseln. (LOL)

\subsection{Hash-Verfahren}

\paragraph{MD5}

MD5 steht für \textbf{Message-Digest Algorithm 5} und gibt bei beliebiger Eingangsgröße einen 128 Bit langen Hashwert aus. Diese Methode wird oft für die Bestätigung der Vollständigkeit von Daten verwendet.

\paragraph{SHA}

SHA steht für \textbf{Seucre-Hash-Algorithm} und sind mehrere standarisierte Hashverfahren, die für digitale Signaturen und Prüfsummer verwendet werden.

\part{Möglichkeiten der Realisierung Allgemein von Ranalter Daniel}
lorem ipsum

\part{Programmrealisierung}
lorem ipsum

\chapter{JobSystem von Porcic Alin und Ranalter Daniel}

Für das Management der Netzwerkgeräte und Netzwerkknoten ist das JobSystem zuständig. Das JobSystem verfügt über einen Zeitplaner, der entscheidet wann eine Netzwerkaufgabe gestartet werden soll.

\section{Netzwerkknoten (=Nodes)}

Netzwerkknoten sind Netzwerkgeräte, die als Ziel für bestimmte Netzwerkaufgaben definiert sind.

\section{Netzwerkaufgaben (=Jobs)}

Netzwerkaufgaben können an Netzwerkknoten drangehängt werden. Wenn eine bestimmte Netzwerkaufgabe ausgeführt wird, wird die Operation auf den Netzwerkknoten ausgeführt.

\subsection{Jobtypen}

Das JobSystem unterscheidet die Jobs in verschiedene Typen. Jeder Typ erledigt eine ganz spezielle Aufgabe im Netzwerk und kann daher verschiedene Resultate erbringen.

\subsubsection{Ping} Dieser Job führt einen Ping-Anfrage auf den jeweiligen Netzwerkknoten aus.

\subsubsection{HTTP} Dieser Job führt eine HTTP-Anfrage auf den jeweiligen Netzwerkknoten aus.

\subsubsection{Port} Diesr Job baut eine TCP-Verbindung zu den jeweiligen Netzwerkknoten auf.

\subsubsection{FOLGEN NOCH}

\section{Funktionsweise}

Das JobSystem besitzt einen Zeitplaner, der ein- und ausgeschalten werden kann. Dieser Zeitplaner behält die Netzwerkknoten und Aufgaben im Auge und ermittelt, wann eine Aufgabe bereit für die Ausführung ist. Falls ein Netzwerkknoten 'inaktiv' ist, wird dieser vom Zeitplaner ignoriert. Auch Netzwerkaufgaben können 'inaktiv' sein und werden dann vom Zeitplaner ebenfalls ignoriert. Wenn eine Aufgabe für die Ausführung bereit ist, startet der Zeitplaner den Job in einem eigenen Thread aus dem internen Threadpool. Nach der Ausführung der Jobs, schreibt der Zeitplaner die Resultate der Operation in die Datenbank (in die JobTable). Während der Ausführung der Aufgabe kann der Netzwerkknoten nicht entfernt werden. Die Änderung der IP-Adresse der Netzwerkknotens während der Ausführung hat keinen Einfluss auf die Ausführung. Erst in der neuen Ausführung wird die neue IP-Adresse für das Ziel verwendet.

\chapter{Notification von Singh Manpreet}
lorem ipsum

\chapter{Database von Stojanovic Marko}
\section{MAD-DB}
lorem ipsum
\subsection{Erklärung}
lorem ipsum
\subsection{Grafische Übersicht}
lorem ipsum
\section{Programmcode}
lorem ipsum

\chapter{Logging von Ranalter Daniel}
lorem ipsum


\part{User Manual von Procic Alin}

\chapter{CLI}

Der Syntax der CLI-Eingagben setzt sich aus drei Bestandteile zusammen: dem Hauptbefehl, den Parametern und den Argumenten. Jede Eingabe muss einen Hauptbefehl definieren und darf nicht mehrere definieren. Jeder Hauptbefehl kann mehrere Parameter definieren und jeder dieser Parameter kann Argumente definieren. Nach Drücken der ENTER-Taste wird die CLI-Eingabe eingelesen und interpretiert. Kann die CLI die Eingabe nicht interpretieren, so gibt sie eine passende Fehlermeldung aus.\\\\
Die CLI unterscheidet die Parameter in obligatorische und optionale Parameter. Die obligatorische Parameter müssen angegeben werden, da sonst die Ausführung des Befehles nicht erfolgen kann. Die optionalen Parameter hingegen können weggelassen werden, müssen aber nicht. Die Anordnung der Parameter und Argumente ist für die CLI irrelevant.\\\\
Mit der Linken- und Rechten-Pfeiltaste kann die Position des Cursors im Eingabefeld verändert werden. Die CLI führt eine Liste der zuletzt eingegeben Befehle. Diese können mit der Oben- und Unten-Pfeiltaste angezeigt werden.

\section{Grundlegende Befehle}

\subsubsection{help}

Durch den Aufruf diese Befehls ohne Parameter, werden alle von der CLI bekannten Befehle aufgelistet. Jeder Befehl hat eine eindeutige Identifikationszahl. Mit dem Parameter \textbf{-id} können Informationen zu einem bestimmten Befehl angefragt werden. Der \textbf{-id} Parameter benötigt die Indentifikationszahl des Befehls als Argument.

\subsubsection{colortest}

Dieser Befehl gibt alle möglichen Farben auf der jeweiligen Konsole aus. Viele Konsolen unterstützen nicht alle Farben, deshalb kann mit diesem Befehl herausgefunden werden, wie bestimmte Farben dargestellt werden.

\subsubsection{info}

Gibt eine kurze Informationen über das Programm aus.

\subsubsection{exit}

Beendet das Programm.

\section{JobSystem Befehle}

\subsubsection{js}

Dieser Befehl gibt eine kurze Übersicht über das aktuell geladene Jobsystem aus. Die Ausgabe enthält Informationen über die Netzwerkknoten, Aufgaben, aktive Knoten, aktive Aufgaben und Kapazitäten des JobSystems.

\subsubsection{js save}

Diese Befehl erlaubt das Abspeichern des JobSystems als JSON-Datei. Der Dateipfad für die Abspeicherung kann als Argument mit dem Parameter \textbf{-f} mitgeteilt werden.

\subsubsection{js load}

Mit dieser Funktion kann ein zuvor abgespeichertes Abbild des JobSystems geladen werden. Der Parameter \textbf{-f} gibt das Abbild an, welches geladen werden soll.

\subsubsection{js nodes}

Dieser Befehl gibt eine Tabelle der initalisierten Netzwerkknoten auf die Konsole aus.

\subsubsection{js jobs}

Die Ausführung diese Befehls gibt eine Tabelle der initalisierten Netzwerkoperationen aus.

\subsubsection{schedule start}

Dieser Befehl startet den Zeitplaner des JobSystems. Nach der Ausführung von diesem Befehl werden die Netzwerkknoten und Netzwerkaufgaben analisiert und bei passender Zeitangabe ausgeführt.

\subsubsection{schedule stop}

Dieser Befehlt stopptet den Zeitplaner des JobSystems.

\subsubsection{node add}

Netzwerkknoten können manuell mit diesem Befehl eingebunden werden. Dieser Befehl hat ingesamt drei Parameter: Name, IP-Adresse und MAC-Adresse. Der Name kann als Argument des Parameter \textbf{-n} mitgeteilt werden, die IP-Adresse mit \textbf{-ip} und die MAC-Adresse mit \textbf{-mac}. Bei der Ausführung des Befehls, erhält der Knoten eine automatisch zugewiesene Indentifikationszahl und eine globale eindeutige Indentifkationszahl (GUID).

\subsubsection{node remove}

Dieser Befehl entfernt einen Netzwerkknoten und die angehängten Netzwerkoperationen. Mit dem Parameter \textbf{-id} kann die Indentifkationszahl des Knoten mitgeteilt werden.

\subsubsection{node edit}

Hiermit können bereits erstellte Netzwerkknoten editiert werden. Dieser Befehl besitzt die gleichen Parameter wie der \textbf{node add} Befehl.

\subsubsection{node start}

Dieser Befehl ändert den Status eines Netzwerkknotens auf 'Aktiv'. Der Parameter \textbf{-id} mit der Indentifikationszahl des Netzwerkknotens muss angegeben werden.

\subsubsection{node stop}

Dieser Befehl ändert den Status eines Netzwerkknotens auf 'Inaktiv'. Der Parameter \textbf{-id} mit der Indentifikationszahl des Netzwerkknotens muss angegeben werden.

\subsubsection{job info}

Mithilfe dieses Befehles können Informationen zu einem bestimmten Job ausgegeben werden.

\subsubsection{job add}

Jeder Aufgabentyp den ein Netzwerkknoten haben kann, definiert einen eigenen Befehl. Jeder \textbf{job add}-Befehl hat folgende Parameter:

\begin{itemize}
\item \textbf{-n}: Dieser Parameter gibt den Jobnamen an. Daher benötigt dieser Befehl den Namen als Argument.
\item \textbf{-id}: Die ID des Netzwerkknoten an dem diese Aufgabe drangehängt werden soll. Der Netzwerkknoten muss existieren, sonst kann der Job nicht hinzugefügt werden.
\item \textbf{-t}: Diese Parameter ist optional, sollte aber trotzdem definiert werden. Das Argument bzw. die Argumente dieses Parameters gibt an, wann der Job ausgeführt werden soll. Möchte man zum Beispiel, dass der Job alle 2000ms ausgeführt wird gibt man '2000' als Argument an. Möchte man einen bestimmen Zeitpunkt oder mehrer Zeitpunkte angeben, so kann man das mit den folgenden Argumenten erreichen:
  \begin{itemize}
  \item 20:15 $\rightarrow$ startet den Job jeden Tag um 20:15 Uhr.
  \item 20:15 21:00 $\rightarrow$ startet den Job jeden Tag um 20:15 und 21:00 Uhr.
  \item 5;20:15 $\rightarrow$ startet den Job jeden Monat am Fünften um 20:15 Uhr.
  \item 5.2;20:15 $\rightarrow$ startet den Job jedes Jahr am Fünften Febuar um 20:15 Uhr.
  \item 5.2.2015;20:15 $\rightarrow$ startet den Job am Fünften Febuar 2015 um 20:15 Uhr.
  \end{itemize}
\end{itemize}

\subsubsection{job remove}

Dieser Befehl benötigt \textbf{-id} als Parameter. Als Argument muss die Indentikiationszahl des Jobs angegeben werden. Jobs, die während der Ausführung dieses Befehls in Ausführung sind, können nicht entfernt werden.

\subsubsection{job edit}

Diese Befehl kann bereits erstellte Jobs modifizieren. 

\subsubsection{job start}

Dieser Befehl ändert den Status einer Netzwerkaufgabe auf 'Aktiv'. Der Parameter \textbf{-id} mit der Indentifikationszahl der Netzwerkaufgabe muss angegeben werden.

\subsubsection{job stop}

Dieser Befehl ändert den Status einer Netzwerkaufgabe auf 'Inaktiv'. Der Parameter \textbf{-id} mit der Indentifikationszahl der Netzwerkaufgabe muss angegeben werden.

\section{Datenbank Befehle}

\subsubsection{db}

Dieser Befehl gibt die Datenbank-Tabellen aus. Falls der Befehl ohne Parameter gestartet wird, wird eine Liste mit allen Tabellen ausgegeben.

\subsubsection{db jobs}

Durch die Eingabe dieses Befehles wird die Datenbank-Tabelle der ausgeführten Operationen ausgegeben.

\subsubsection{db jobs remove}

Dieser Befehl erlaubt das Löschen von bestimmten Datensätze aus der 'JobTable'.

\subsubsection{db jobs remove all}

Dieser Befehl löscht alle Datensätze aus der 'JobTable'.

\subsubsection{db summary}

Die Eingabe dieses Befehls bewirkt die Ausgabe einer Datenbank-Tabelle der 'SummaryTable'.

\subsubsection{db summary create}

Die Berechnung und das Schreiben der Zusammenfassung kann durch eingeben dieses Befehls erreicht werden.

\subsubsection{db summary remove}

Das Entfernen von Datensätze aus der 'SummaryTable' erfolgt durch die Ausführung von diesem Befehl.

\subsubsection{db summary remove all}

Entfernt alle Datensätze aus der 'SummaryTable'.

\subsubsection{db memo}

Gibt den Inhalt der Memos aus der Datenbank auf die Konsole aus.

\subsubsection{db memo add}

In der Datenbank steht für jeden Netzwerkknoten zwei Felder für Memos frei. Ein kurzes Memo-Feld und ein längeres Memo-Feld. Durch die Ausführung dieses Befehls können Memos hinzugefügt werden.

\subsubsection{db memo remove}

Dieser Befehl entfernt Memos aus der Datenbank.

\section{Anwendungsbeispiele}

\subsection{Netzwerkknoten und Netzwerkaufgaben}

Es soll manuell ein Netzwerkknoten hinzugefügt werden. Der Netzwerkknoten sieht wie folgt aus:

\begin{itemize}
  \item Hostname = MeinPC
  \item IP-Adresse = 10.0.0.120
  \item MAC-Adresse = FF:00:00:00:11
\end{itemize}

Um einen Netzwerkknoten hinzuzufügen muss der Befehl 'node add' ausgeführt werden. Dieser Befehl besitzt drei obligatorische Parameter mit jeweils einem Argument. Die Eingabe sieht wie folgt aus:\\\\

\textbf{node add -n MeinPC -ip 10.0.0.120 -mac FF:00:00:00:11}\\\\

Nach der Bestätigung mit der ENTER-Taste wird der Knoten erstellt und in das JobSystem eingebunden. Es sollen nun drei Netzwerkoperationen auf diesen Knoten ausgeführt werden:

\begin{itemize}
\item Ping-Anfrage alle 10s
\item Port-Scan auf Port 443 jeden Tag um 19:30
\item HTTP-Anfrage auf Port 80 jeden Monat am ersten Tag um 20:00
\end{itemize}

Das wird mithilfe der folgenden Befehle erreicht:

\begin{itemize}
\item \textbf{job add ping -n MeinPing -id 0 -t 10000}
\item \textbf{job add port -n MeinPortScan -id 0 -t 19:30 -p 443}
\item \textbf{job add http -n MeinHttp -id 0 -t 1;20:00 -p 80}
\end{itemize}

Das Argument des Parameters '-id' gibt die ID des Netzwerkknoten an, an dem die Aufgabe drangehängt werden soll. Der Parameter '-t' definiert wann diese Aufgabe ausgeführt werden soll. Port-Scans und HTTP-Anfragen können auch einen Port über den Parameter '-p' definieren.\\\\
Zurzeit ist der Zeitplaner des JobSystems ausgeschalten, der Netzwerkknoten ist 'inaktive' und die drei Aufgaben ebenfalls. Damit die Aufgaben ausgeführt werden können muss der Zeitplaner aktiviert werden. Das geschieht durch den folgenden Befehl:\\\\
\textbf{schedule start}\\\\
Nun läuft der Zeitplaner, jedoch ignoriert er den Netzwerkknoten und alle darunterliegenden Aufgaben, da der Netzwerkknoten inaktive ist. Um einen Netzwerkknoten zu aktivieren reicht die Ausführung des folgenen Befehls:\\\\
\textbf{node start -id 0}\\\\
Damit der Zeitplaner die Aufgaben des jeweiligen Netzwerkknoten zur richtigen Zeit ausführen kann, müssen die Aufgaben aktiviert werden. Das kann durch die folgende Eingabe erreicht werden:\\\\
\textbf{job start -id 0}\\
\textbf{job start -id 1}\\
\textbf{job start -id 2}\\\\
Der Parameter '-id' gibt nicht den Knoten an, sondern die Identifikationszahl der Aufgabe an. Jeder Knoten hat eine ID, aber auch jede Aufgabe hat eine eindeutige Zuweisung. Nun werden die Aufgaben zu den definierten Zeitpunkten ausgeführt und die Ergebnisse der Ausführung werden in die Datenbank geschrieben. Mit diesem Befehl können die Aufgaben angesehen werden: \\\\
\textbf{js jobs}\\\\
Nach der Ausführung wird eine Tabelle mit den Aufgaben ausgegeben.

\chapter{CLIClient}

Der CLI-Client erstellt bei der ersten Ausführung eine Konfigurationsdatei im gleichen Ordner wie die ausführbare Datei. Dort kann der Zieladresse und Authentifikations-Passwort eingegeben werden. Sobald die Verbindung steht, kann die CLI ganz normal verwendet werden.\\\\
Warnung: es können sich mehrere Clients gleichzeitig anmelden. Das Programm müsste in der Theorie trotzdem funktionieren, jedoch wurde dieses Szenario nicht gründlich genug getestet und ist daher nicht empfohlen.

\chapter{CLIServer}

Der CLI-Server ist im Hauptprogramm integriert und kann mit dem Argument '-cliserver' gestartet werden. Der Port lässt sich über die Konfigurationsdatei 'data/mad.conf' verändern. Standardmäßig läuft er auf Port 2222. Das Passwort mit dem sich der CLIClient authentifizeren muss, kann im Feld 'AES-PASS' ebenfalls eingerichtet werden.

\part{Quellverzeichnis}
lorem ipsum

\end{document}
